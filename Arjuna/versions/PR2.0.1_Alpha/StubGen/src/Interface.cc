/*
 * Copyright (C) 1993
 *
 * Department of Computing Science,
 * The University,
 * Newcastle upon Tyne,
 * UK.
 *
 * $Id: Interface.cc,v 1.1 1993/11/03 14:47:59 nmcl Exp $
 */

/*
 * Stub generator interface class.
 *
 */

#include <stddef.h>
#include <strstream.h>
#include <fstream.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

extern "C" char *mktemp(char *);

#ifdef DEBUG
#   include "Debug.h"
#endif

#ifndef ERROR_H_
#  include "Error.h"
#endif

#ifndef GLOBALINF_H_
#  include "GlobalInf.h"
#endif

#ifndef LINKAGE_H_
#  include "Linkage.h"
#endif

#ifndef UTILITY_H_
#  include "Utility.h"
#endif

#ifndef DECL_H_
#  include "Decl.h"
#endif

#ifndef INTERFACE_H_
#  include "Interface.h"
#endif

static const char RCSid[] = "$Id: Interface.cc,v 1.1 1993/11/03 14:47:59 nmcl Exp $";

char *InterfaceDef::cppArgs[MAXCPPARGS] = {0};
char *InterfaceDef::cppProgs[MAXCPPPROGS] = {0};

/*
 * Public operations
 */

/*
 * Constructor: remember interface filename and create and initialise the
 * required output streams. Name will end in either .h (need cpp)
 * or .i (cpp already run). Having set cppFilename change interface name
 * suffix to .h regardless
 * Also attempts to set up a set of program names to run to preprocess
 * the user's file.
 */

InterfaceDef::InterfaceDef ( const String& ifName )
                           : cppIndex(1),
			     cppFileName(0),
			     inputFname(ifName),
			     interfaceName(ifName)
{
    int i = 0;
    int progIndex = 0;
    String if_root = ifName(0, ifName.size()-2);
    String if_tail = ifName.rindex('.');
    char *ccRootDir = ::getenv("CCROOTDIR");

    GlobalInfo::setCurrentIf(this);
    
    /* Set up a selection of programs to run as "cpp" */

    for (i = 0; i < MAXCPPPROGS; i++)
	 cppProgs[i] = 0;

#ifndef _AIX
    /* xlc does not understand the #pragma statements in some files */
    /* First try the command used to compile the stub genrator */

    if ((cppProgs[progIndex] = locateProg(COMPILER_NAME)) != 0)
	progIndex++;
#endif

    /* Since we use execvp just trying the compiler name might work */

    cppProgs[progIndex++] = COMPILER_NAME;

    /* Then try CCROOTDIR/cpp (as done in Sun C++) */

    if (ccRootDir != 0)
    {
	int sLen = strlen(ccRootDir);	/* sLen does not include null */
	char *cppPath = new char[sLen + 5];

	::strcpy(cppPath, ccRootDir);
	if (cppPath[sLen-1] != '/')
	    cppPath[sLen-1] = '/';

	::strcat(cppPath, "cpp");
	if ((cppProgs[progIndex] = locateProg(cppPath)) != 0)
	    progIndex++;

	delete [] cppPath;
    }

    /* Finally any old cpp we can find */

#ifdef SYSV
    if ((cppProgs[progIndex] = locateProg("/usr/ccs/lib/cpp")) != 0)
	    progIndex++;
#endif

    if ((cppProgs[progIndex] = locateProg("/usr/lib/cpp")) != 0)
	    progIndex++;

    if ((cppProgs[progIndex] = locateProg("/lib/cpp")) != 0)
	    progIndex++;

    if (if_tail == ".h")
    {
	/* generate temorary file name */
	char *ifName = "/tmp/IFtmpXXXXXX";
    
	cppFileName = new char[strlen(ifName) + 1];
	::strcpy(cppFileName, ifName);
	::mktemp(cppFileName);

	inputFname = cppFileName;
    }
    else
	interfaceName = if_root +".h";

#ifdef SHORTNAMES	 
    headerFname = if_root + "_s.h";
#else
    headerFname = if_root + "_stub.h";
#endif
}

/*
 * Cleanup. Ensure the temporary file generated by cpp is removed.
 */

InterfaceDef::~InterfaceDef ()
{
    if (cppFileName != 0)
    {
	::unlink(cppFileName);

	delete [] cppFileName;
    }
}

void InterfaceDef::addCppArg ( const char *arg )
{
    if (cppIndex < MAXCPPARGS)
    {
	if (arg)
	{
	    int len = ::strlen(arg);
	    char *temp = new char[len+1];

	    ::strcpy(temp,arg);
	    cppArgs[cppIndex++] = temp;

	    if ((len > 2) && (strncmp(temp,"-I",2) == 0))
	    {
		/* Include directory - note it for later reference */
		
		GlobalInfo::addIncDir(String(temp+2));
	    }
	}
    }
    else
	fatal("internal cpp argument limit exceeded");
}

/*
 * Private operations
 */

#ifdef _AIX
extern "C" int yyparse();
#endif

int InterfaceDef::parseInterface ()
{
#ifndef _AIX
    extern int yyparse();
#endif
    int status;

    if ((status = preprocess()) == 0)
	return yyparse();
    else
	return status;
}

/*
 * Preprocess the interface file. This simply runs cpp to get rid of
 * #includes, #defines, etc. Cpp is run with STUB defined so that the file
 * can contain special stub generator only stuff.
 * Cpp is only run if the interface name ends with .h.
 * If it ends with .i the interface is assumed to to be already preprocessed
 * We try to run several cpps in turn until one succeeds
 * 1) Try (COMPILER) -E (eg CC2.1 -E)
 * 2) Try CCROOTDIR/cpp
 * 3) Finally try /lib/cpp
 */

int InterfaceDef::preprocess ()
{
    struct stat statBuf;
    long pid   = 0;
    int cppCmd = 0;

#ifdef HAVE_UNION_WAIT
    union wait w;
#else
    int w;
#endif

    cppArgs[cppIndex++] = interfaceName;

    /* redirect output to file if needed */

    if (cppFileName)
    {
	if (::freopen(cppFileName, "w", stdout) == 0)
	{
	    error("could not open cpp output file");
	    return 1;
	}
    
	while (cppProgs[cppCmd] != 0)
	{
	    /* Set which cpp to use */

	    cppArgs[0] = cppProgs[cppCmd];
	
	    if ((pid = ::fork()) == 0)
	    {
		::execvp(cppArgs[0], cppArgs);
		exit(errno);
	    }
	    
	    while (pid != wait(&w))
	    {
		/* DO NOTHING */
	    }
	    
	    if (WEXITSTATUS(w) != 0)
	    {
		errorStream << cppArgs[0] << " returned non-zero exit status";
		error(errorStream);
	    }
	
	    /* Ensure some output was generated */

	    if ((stat((const char *)inputFname, &statBuf) == 0) &&
		(statBuf.st_size > 0))
	    {
		break;
	    }

	    /* Nooutput - try different cpp */

	    cppCmd++;
	}
    }

    /* Lex reads from stdin - force that to be the preprocesed file */
     
    if (::freopen(inputFname, "r", stdin) == 0)
    {
	error("could not reopen cpp output file");
	return 1;
    }

    return 0;
}

/*
 * This is the start of the hard work. Parse the interface file.
 * If this works output the stub header and code for this interface
 * definition. 
 */

void InterfaceDef::process ()
{
    GlobalInfo::setInterfaceName(interfaceName);
    
    parseInterface();
    if (errorLog.noOfErrors() == 0)
    {
	if (GlobalInfo::getStubGlobalMods() != STUB_NORENAME)
	    produceStubs();
	else
	    caution("@NoRename in effect - no output produced");
    }
    errorLog.summary(cout);
}

void InterfaceDef::produceStubs ()
{
    String defName = interfaceName.rindex('/');
    int declnum = 0;
    Declaration *currentDecl;
    Boolean linkageOpen = FALSE;
    Linkage *currentLinkage = GlobalInfo::getLinkage();
    Linkage *lastLinkage = currentLinkage;
    ofstream headerStream;

    headerStream.open(headerFname);

    if (defName == NullString)
	defName = interfaceName;
    else
	defName = defName(1,0);

    defName = defName(0,defName.size() - 2).touppercase();
    defName += "_H_";

    GlobalInfo::stamp(headerStream);

    /* Standard prolog for stub header file */

    headerStream << "#ifndef " << defName << "\n";
    headerStream << "#define " << defName << "\n\n";

    /* First print list of standard includes */

    headerStream << "class RpcBuffer;\n";
    headerStream << "class RpcControl;\n\n";

    /* Walk list of known declarations producing stubs if required */

    while ((currentDecl = GlobalInfo::getDecl(declnum++)) != 0)
    {
#ifdef DEBUG
	debugStream << "Processing : " << currentDecl->getName() 
	    << "(" << (void *)currentDecl << "): ";
	_debug.dbgFlush(GLOBAL, FAC_STUBGEN, VIS_PUBLIC);
#endif

	Location currentLoc = currentDecl->getLoc();

	errorLocation = currentLoc;
	currentDecl->freezeDecl();
   
	if (currentLoc.getFileName() == interfaceName)
	{
	    if ((currentLinkage = currentDecl->getLinkage()) != lastLinkage)
	    {
		if (linkageOpen)
		{
		    headerStream << "\n}\n";
		}
		lastLinkage = currentLinkage;
		headerStream << currentLinkage << "\n{\n";
		linkageOpen = TRUE;
	    }
	    currentDecl->produceAllStubs(headerStream);
	}
    }

    if (linkageOpen)
    {
	headerStream << "\n}\n";
    }

    headerStream << "\n#endif  /* " << defName << " */\n" << flush;
}

/*
 * save cpp output file. Primarily for debugging purposes
 */

void InterfaceDef::save ()
{
    String fname = interfaceName(0, interfaceName.size()-2);
    String ofName = fname + ".i";
    char iobuff[4096];

    if (cppFileName)
    {
	ofstream ofile(ofName);

	if (ofile)
	{
	    ifstream ifile(cppFileName);

	    while (ifile != 0)
	    {
		ifile.read(iobuff, 4096);
		ofile.write(iobuff, ifile.gcount());
	    }
	} else
	{
	    errorStream << "cannot create output file: " << fname << "\n";
	    error(errorStream);
	}
    }
    else
    {
	errorLog.enableWarnings(TRUE);
	caution("+S ignored with already pre-processed interface");
    }
}
#ifdef NO_INLINES
#  define INTERFACE_CC_
#  include "Interface.n"
#  undef INTERFACE_CC_
#endif
