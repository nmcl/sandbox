/*
 * Copyright (C) 1993
 *
 * Department of Computing Science,
 * The University,
 * Newcastle upon Tyne,
 * UK.
 *
 * $Id: Interface.cc,v 1.30 1993/03/22 09:31:17 ngdp Exp $
 */

/*
 * Stub generator interface class.
 *
 */

#include <stddef.h>
#include <strstream.h>
#include <fstream.h>
#include <sys/wait.h>
#include <sys/stat.h>
#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>

extern "C" char *mktemp(char *);

#ifdef DEBUG
#   include "Debug.h"
#endif

#ifndef ERROR_H_
#  include "Error.h"
#endif

#ifndef GLOBALINF_H_
#  include "GlobalInf.h"
#endif

#ifndef LINKAGE_H_
#  include "Linkage.h"
#endif

#ifndef UTILITY_H_
#  include "Utility.h"
#endif

#ifndef DECL_H_
#  include "Decl.h"
#endif

#ifndef INTERFACE_H_
#  include "Interface.h"
#endif

static const char RCSid[] = "$Id: Interface.cc,v 1.30 1993/03/22 09:31:17 ngdp Exp $";

char *InterfaceDef::cppArgs[maxCppArgs] = {0};
char *InterfaceDef::cppProgs[maxCppProgs] = {0};

/*
 * Public operations
 */

/*
 * Constructor: remember interface filename and create and initialise the
 * required output streams. Name will end in either .h (need cpp)
 * or .i (cpp already run). Having set cppFilename change interface name
 * suffix to .h regardless
 * Also attempts to set up a set of program names to run to preprocess
 * the user's file.
 */

InterfaceDef::InterfaceDef ( const String& ifname )
                           : cppIndex(1),
			     cppFilename(0),
			     inputFname(ifname),
			     interfaceName(ifname)
{
    int i = 0;
    int progIndex = 0;
    String if_root = ifname(0, ifname.size()-2);
    String if_tail = ifname.rindex('.');
    char *ccRootDir = ::getenv("CCROOTDIR");

    GlobalInfo::set_current_if(this);
    
    /* Set up a selection of programs to run as "cpp" */

    for (i = 0; i < maxCppProgs; i++)
	 cppProgs[i] = 0;

    /* First try the command used to compile the stub genrator */

    if ((cppProgs[progIndex] = locateProg(COMPILER_NAME)) != 0)
	progIndex++;

    /* Then try CCROOTDIR/cpp (as done in Sun C++) */

    if (ccRootDir != 0)
    {
	int sLen = strlen(ccRootDir);	/* sLen does not include null */
	char *cppPath = new char[sLen + 5];

	::strcpy(cppPath, ccRootDir);
	if (cppPath[sLen-1] != '/')
	    cppPath[sLen-1] = '/';

	::strcat(cppPath, "cpp");
	if ((cppProgs[progIndex] = locateProg(cppPath)) != 0)
	    progIndex++;

	delete [] cppPath;
    }

    /* Finally any old cpp we can find */

    if ((cppProgs[progIndex] = locateProg("/usr/lib/cpp")) != 0)
	    progIndex++;

    if ((cppProgs[progIndex] = locateProg("/lib/cpp")) != 0)
	    progIndex++;

    if (if_tail == ".h")
    {
	/* generate temorary file name */
	char *ifname = "/tmp/IFtmpXXXXXX";
    
	cppFilename = new char[strlen(ifname) + 1];
	::strcpy(cppFilename, ifname);
	::mktemp(cppFilename);

	inputFname = cppFilename;
    }
    else
	interfaceName = if_root +".h";

#ifdef SHORTNAMES	 
    headerFname = if_root + "_s.h";
#else
    headerFname = if_root + "_stub.h";
#endif
}

/*
 * Cleanup. Ensure the temporary file generated by cpp is removed.
 */

InterfaceDef::~InterfaceDef ()
{
    if (cppFilename != 0)
    {
	::unlink(cppFilename);

	delete [] cppFilename;
    }
}

void InterfaceDef::addCppArg ( const char *arg )
{
    if (cppIndex < maxCppArgs)
    {
	if (arg)
	{
	    int len = ::strlen(arg);
	    char *temp = new char[len+1];

	    ::strcpy(temp,arg);
	    cppArgs[cppIndex++] = temp;

	    if ((len > 2) && (strncmp(temp,"-I",2) == 0))
	    {
		/* Include directory - note it for later reference */
		
		GlobalInfo::add_inc_dir(String(temp+2));
	    }
	}
    }
    else
	fatal("internal cpp argument limit exceeded");
}

/*
 * Private operations
 */

int InterfaceDef::parseInterface ()
{
    extern int yyparse();
    int status;

    if ((status = preprocess()) == 0)
	return yyparse();
    else
	return status;
}

/*
 * Preprocess the interface file. This simply runs cpp to get rid of
 * #includes, #defines, etc. Cpp is run with STUB defined so that the file
 * can contain special stub generator only stuff.
 * Cpp is only run if the interface name ends with .h.
 * If it ends with .i the interface is assumed to to be already preprocessed
 * We try to run several cpps in turn until one succeeds
 * 1) Try (COMPILER) -E (eg CC2.1 -E)
 * 2) Try CCROOTDIR/cpp
 * 3) Finally try /lib/cpp
 */

int InterfaceDef::preprocess ()
{
    struct stat statBuf;
    long pid   = 0;
    int cppCmd = 0;

#ifdef HAVE_UNION_WAIT
    union wait w;
#else
    int w;
#endif

    cppArgs[cppIndex++] = interfaceName;

    /* redirect output to file if needed */

    if (cppFilename)
    {
	if (::freopen(cppFilename, "w", stdout) == 0)
	{
	    error("could not open cpp output file");
	    return 1;
	}
    
	while (cppProgs[cppCmd] != 0)
	{
	    /* Set which cpp to use */

	    cppArgs[0] = cppProgs[cppCmd];
	
	    if ((pid = ::fork()) == 0)
	    {
		::execv(cppArgs[0], cppArgs);
		exit(errno);
	    }
	    
	    while (pid != wait(&w))
	    {
		/* DO NOTHING */
	    }
	    
	    if (WEXITSTATUS(w) != 0)
	    {
		error_stream << cppArgs[0] << " returned non-zero exit status";
		error(error_stream);
	    }
	
	    /* Ensure some output was generated */

	    if ((stat((const char *)inputFname, &statBuf) == 0) &&
		(statBuf.st_size > 0))
	    {
		break;
	    }

	    /* Nooutput - try different cpp */

	    cppCmd++;
	}
    }

    /* Lex reads from stdin - force that to be the preprocesed file */
     
    if (::freopen(inputFname, "r", stdin) == 0)
    {
	error("could not reopen cpp output file");
	return 1;
    }

    return 0;
}

/*
 * This is the start of the hard work. Parse the interface file.
 * If this works output the stub header and code for this interface
 * definition. 
 */

void InterfaceDef::process ()
{
    GlobalInfo::set_interfacename(interfaceName);
    
    parseInterface();
    if (error_log.no_of_errors() == 0)
    {
	if (GlobalInfo::get_stub_globalmods() != STUB_NORENAME)
	    produceStubs();
	else
	    warning("@NoRename in effect - no output produced");
    }
    error_log.summary(cout);
}

void InterfaceDef::produceStubs ()
{
    String defname = interfaceName.rindex('/');
    int declnum = 0;
    Declaration *current_decl;
    Boolean linkageOpen = FALSE;
    Linkage *currentLinkage = GlobalInfo::get_linkage();
    Linkage *lastLinkage = currentLinkage;
    ofstream header_stream;

    header_stream.open(headerFname);

    if (defname == NullString)
	defname = interfaceName;
    else
	defname = defname(1,0);

    defname = defname(0,defname.size() - 2).touppercase();
    defname += "_H_";

    GlobalInfo::stamp(header_stream);

    /* Standard prolog for stub header file */

    header_stream << "#ifndef " << defname << "\n";
    header_stream << "#define " << defname << "\n\n";

    /* First print list of standard includes */

    header_stream << "#include <StubGen/Abort.h>\n";
    header_stream << "#include <StubGen/RpcBuffer.h>\n";
    header_stream << "#include <StubGen/ClientRpc.h>\n";
    header_stream << "#include <StubGen/ServerRpc.h>\n";
    header_stream << "#include <StubGen/RpcControl.h>\n\n";

    /* Walk list of known declarations producing stubs if required */

    while ((current_decl = GlobalInfo::get_decl(declnum++)) != 0)
    {
#ifdef DEBUG
	debug_stream << "Processing : " << current_decl->get_name() 
	    << "(" << (void *)current_decl << "): ";
	_debug.dbg_flush(GLOBAL, FAC_STUBGEN, VIS_PUBLIC);
#endif

	Location current_loc = current_decl->get_loc();

	error_location = current_loc;
	current_decl->freeze_decl();
   
	if (current_loc.get_filename() == interfaceName)
	{
	    if ((currentLinkage = current_decl->get_linkage()) != lastLinkage)
	    {
		if (linkageOpen)
		{
		    header_stream << "\n}\n";
		}
		lastLinkage = currentLinkage;
		header_stream << currentLinkage << "\n{\n";
		linkageOpen = TRUE;
	    }
	    current_decl->produce_stubs(header_stream);
	}
    }

    if (linkageOpen)
    {
	header_stream << "\n}\n";
    }

    header_stream << "\n#endif  /* " << defname << " */\n" << flush;
}

/*
 * save cpp output file. Primarily for debugging purposes
 */

void InterfaceDef::save ()
{
    String fname = interfaceName(0, interfaceName.size()-2);
    String ofname = fname + ".i";
    char iobuff[4096];

    if (cppFilename)
    {
	ofstream ofile(ofname);

	if (ofile)
	{
	    ifstream ifile(cppFilename);

	    while (ifile != 0)
	    {
		ifile.read(iobuff, 4096);
		ofile.write(iobuff, ifile.gcount());
	    }
	} else
	{
	    error_stream << "cannot create output file: " << fname << "\n";
	    error(error_stream);
	}
    }
    else
    {
	error_log.do_warnings();
	warning("+S ignored with already pre-processed interface");
    }
}
#ifdef NO_INLINES
#  define INTERFACE_CC_
#  include "Interface.n"
#  undef INTERFACE_CC_
#endif
