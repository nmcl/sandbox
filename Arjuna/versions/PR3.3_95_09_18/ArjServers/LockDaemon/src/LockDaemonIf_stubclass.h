/*
 * Automatically Generated by:
 * Arjuna Stub Generator Version 5.5.3 - $Date: 1996/09/10 15:38:44 $
 *
 * Do Not Edit By Hand
 *
 */

#ifdef STUB
#  pragma @NoRename
#endif

#ifndef STUB
#include <StubGen/RpcBuffer.h>
#include <StubGen/ClientRpcMan.h>


#ifndef LOCKDAEMONIF_SERVER
#undef LockDaemonIf
#define LockDaemonIf RemoteLockDaemonIf
#endif

class RemoteLockDaemonIf
{
public:
	RemoteLockDaemonIf ( Boolean& , ClientRpcManager *_cRpcMan_ = ClientRpcManager::createInstance("LockDaemon",1));
	~RemoteLockDaemonIf ( );
	void propagate ( const Uid& , const Uid& , const TypeName , Boolean& );
	void releaseAll ( const Uid& , const Uid& , const TypeName , Boolean& );
	void releaselock ( const Uid& , const Uid& , const TypeName , Boolean& );
	void setlock ( Lock* , const Uid& , const TypeName , LockResult& );
protected:
	RemoteLockDaemonIf(const ClientRpcManager&, const RpcBuffer&);
private:
	ClientRpcManager _clientManager;
	RpcBuffer _myHashVal;
}
;


#ifdef LOCKDAEMONIF_SERVER
#undef LockDaemonIf
#define LockDaemonIf LocalLockDaemonIf
#endif

class LocalLockDaemonIf;

class ServerLockDaemonIf
{

public:
	ServerLockDaemonIf ();
	~ServerLockDaemonIf ();

	void serve (int, char **);
	Int32 dispatchToClass (LocalLockDaemonIf*, Int32, RpcBuffer&, RpcBuffer&);

private:
	Int32 dispatchToOper (LocalLockDaemonIf *,Int32, RpcBuffer&, RpcBuffer&);

	Int32 LockDaemonIf3587918(LocalLockDaemonIf *, RpcBuffer&, RpcBuffer&);
	Int32 LockDaemonIf75959190(LocalLockDaemonIf *, RpcBuffer&, RpcBuffer&);
	Int32 propagate119239758(LocalLockDaemonIf *, RpcBuffer&, RpcBuffer&);
	Int32 releaseAll99837102(LocalLockDaemonIf *, RpcBuffer&, RpcBuffer&);
	Int32 releaselock59903054(LocalLockDaemonIf *, RpcBuffer&, RpcBuffer&);
	Int32 setlock246490452(LocalLockDaemonIf *, RpcBuffer&, RpcBuffer&);

	LocalLockDaemonIf *theRealObject;
	RpcBuffer _constructArgs_;
	Int32 _constructOpcode_;
	Int32 _constructRefCount_;
	RpcBuffer _constructResult_;
};
#endif


#ifdef STUB
#  define LocalLockDaemonIf LockDaemonIf
#endif

/* @Remote, @NoMarshall */ class LocalLockDaemonIf
{
public:
	/* @NoMarshall */ LocalLockDaemonIf ( Boolean& );
	/* @NoMarshall */ ~LocalLockDaemonIf ( );
	/* @NoMarshall */ void propagate ( const Uid& , const Uid& , const TypeName , Boolean& );
	/* @NoMarshall */ void releaseAll ( const Uid& , const Uid& , const TypeName , Boolean& );
	/* @NoMarshall */ void releaselock ( const Uid& , const Uid& , const TypeName , Boolean& );
	/* @NoMarshall */ void setlock ( /* @in */ Lock* , const Uid& , const TypeName , LockResult& );
private:
	/* @NoMarshall */ Boolean doRelease ( const Uid& , const Uid& , const TypeName , Boolean );
	/* @NoMarshall */ Boolean initialise ( );
	/* @NoMarshall */ Boolean isAncestorOf ( const Lock& , const Lock& );
	/* @NoMarshall */ ConflictType lockConflict ( Lock* , const Uid& , const TypeName );
	LockTable* locksHeld;
	Semaphore* mutex;
};

