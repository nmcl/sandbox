/*
 * Automatically Generated by:
 * Arjuna Stub Generator Version 5.5.3 - $Date: 1996/09/10 15:38:44 $
 *
 * Do Not Edit By Hand
 *
 */

#ifdef STUB
#  pragma @NoRename
#endif

#ifndef STUB
#include <StubGen/RpcBuffer.h>
#include <StubGen/ClientRpcMan.h>


#ifndef LOCKMANAGER_SERVER
#undef LockManager
#define LockManager RemoteLockManager
#endif

class RemoteLockManager: public RemoteStateManager
{
public:
	virtual Boolean restore_state ( ObjectState& , ObjectType ) = 0;
	virtual Boolean save_state ( ObjectState& , ObjectType ) = 0;
	virtual const TypeName type ( ) const ;
protected:
	RemoteLockManager(const ClientRpcManager&, const RpcBuffer&);
	~RemoteLockManager ( );
private:
	ClientRpcManager _clientManager;
	RpcBuffer _myHashVal;
}
;


#ifdef LOCKMANAGER_SERVER
#undef LockManager
#define LockManager LocalLockManager
#endif

class LocalLockManager;

class ServerLockManager: public ServerStateManager
{

public:
	ServerLockManager ();
	~ServerLockManager ();

	void serve (int, char **);
	Int32 dispatchToClass (LocalLockManager*, Int32, RpcBuffer&, RpcBuffer&);

private:
	Int32 dispatchToOper (LocalLockManager *,Int32, RpcBuffer&, RpcBuffer&);

	Int32 restore_state152312933(LocalLockManager *, RpcBuffer&, RpcBuffer&);
	Int32 save_state31159925(LocalLockManager *, RpcBuffer&, RpcBuffer&);
	Int32 type186814694(LocalLockManager *, RpcBuffer&, RpcBuffer&);

	LocalLockManager *theRealObject;
	RpcBuffer _constructArgs_;
	Int32 _constructOpcode_;
	Int32 _constructRefCount_;
	RpcBuffer _constructResult_;
};
#endif


#ifdef STUB
#  define LocalLockManager LockManager
#endif

/* @Remote, @NoMarshall */ class LocalLockManager: public LocalStateManager
{
public:
	/* @NoRemote @NoMarshall */ Boolean propagate ( const Uid& , const Uid& );
	/* @NoRemote @NoMarshall */ Boolean releaseAll ( const Uid& );
	/* @NoRemote @NoMarshall */ Boolean releaselock ( const Uid& );
	/* @NoRemote @NoMarshall */ LockResult setlock ( Lock* , int  = 100, unsigned  int  = 250000);
	/* @NoRemote @NoMarshall */ virtual ostream& print ( ostream& ) const ;
	/* @NoRemote @NoMarshall */ virtual ostream& print ( ostream& );
	/* @NoMarshall */ virtual Boolean restore_state ( ObjectState& , ObjectType ) = 0;
	/* @NoMarshall */ virtual Boolean save_state ( ObjectState& , ObjectType ) = 0;
	/* @NoMarshall */ virtual const TypeName type ( ) const ;
protected:
	/* @NoMarshall */ LocalLockManager ( ObjectType  = RECOVERABLE, Boolean  = false, Boolean  = false);
	/* @NoMarshall */ LocalLockManager ( const Uid& , ObjectType  = ANDPERSISTENT, Boolean  = false);
	/* @NoMarshall */ ~LocalLockManager ( );
	/* @NoMarshall */ virtual void terminate ( );
	/* @NoMarshall */ Boolean useLockDaemon ( );
private:
	/* @NoMarshall */ void cleanUp ( );
	/* @NoMarshall */ Boolean doRelease ( const Uid& , Boolean );
	/* @NoMarshall */ void freeState ( );
	/* @NoMarshall */ Boolean initialise ( );
	/* @NoMarshall */ Boolean isAncestorOf ( const Lock& );
	/* @NoMarshall */ Boolean loadState ( );
	/* @NoMarshall */ ConflictType lockConflict ( const Lock& );
	/* @NoMarshall */ Boolean unloadState ( );
	key_t systemKey;
	LockList* locksHeld;
	LockStore* lockStore;
	Semaphore* mutex;
	Boolean stateLoaded;
	Boolean hasBeenLocked;
	Boolean useDaemon;
	Boolean objectLocked;
	LockDaemon* lockDaemon;
};

