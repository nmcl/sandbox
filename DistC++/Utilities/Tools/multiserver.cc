/*
 * Copyright 1997,
 * Department of Computing Science, University of Newcastle upon Tyne, UK.
 *
 * $Id: multiserver.cc,v 1.2 1997/10/03 14:36:13 nmcl Exp $
 */

#include <System/fstream.h>
#include <System/stdlib.h>
#include <System/unistd.h>
#include <System/string.h>
#include <System/iostream.h>

static const char* defaultName = "servercode.cc";
static const int maxClasses = 10;

ofstream* output = 0;
int classIndex = 0;
int printInfo = 0;
char* classes[maxClasses];

void usage (const char* name)
{
    cout << "Usage: " << name << " -servercode <name> -class <obj> [-info] [-help]" << endl;
}

void generateHeaders ()
{
    for (int j = 0; j < classIndex; j++)
    {
	(*output) << "#include <" << classes[j] << "_stub.h>\n";
    }
}

void generateThreadBody ()
{
    for (int i = 0; i < classIndex; i++)
    {
	(*output) << "\nvoid* " << classes[i] << "Body (void* param)\n";
	(*output) << "{\n";
	(*output) << "Server" << classes[i] << " one" << classes[i] << ";\n";
	(*output) << "args* data = (args*) param;\n\n";

	if (printInfo)
	{
	    (*output) << "cout << \"Server" <<  classes[i] << " started\" << endl;\n\n";
	}
	
	(*output) << "one" << classes[i] << ".serve(data->argc, data->argv);\n\n";
	(*output) << "return 0;\n";
	(*output) << "}\n";
    }
}

void generateThreadCall ()
{
    for (int i = 0; i < classIndex -1; i++)
    {
	(*output) << "Thread* t" << i << " = new Thread(" << classes[i] << "Body, data);\n";
	(*output) << "t" << i << "->resume();\n";
    }
}

/*
 * This utility creates servers with multiple classes.
 * Such servers cannot be used in conjunction with the
 * rpc manager, so must be started by hand. This also means
 * that clients must be created with knowledge of the ports
 * of these servers, since typically they would get this
 * information from the manager.
 *
 * The options are:
 *
 * -servercode : the name of the file to create the code in.
 * -class      : the class name to serve - any number of these can be given.
 * -info       : add some extra print statements to the code as each class
 *               is created.
 */

int main (int argc, char** argv)
{
    for (int i = 0; i < argc; i++)
    {
	if (::strcmp(argv[i], "-servercode") == 0)
	    output = new ofstream(argv[i+1]);
	if (::strcmp(argv[i], "-class") == 0)
	    classes[classIndex++] = argv[i+1];
	if (::strcmp(argv[i], "-info") == 0)
	    printInfo = 1;
	if (::strcmp(argv[i], "-help") == 0)
	{
	    usage(argv[0]);
	    return 0;
	}
    }

    if (classIndex > maxClasses)
    {
	cerr << "Sorry, too many classes. Maximum " << maxClasses << endl;
	return -1;
    }

    if (classIndex == 0)
    {
	cerr << "No class specified." << endl;
	return -1;
    }
        
    if (!output)
	output = new ofstream(defaultName);

    /*
     * Stick in the standard disclaimer.
     */
    
    (*output) << "/*\n";
    (*output) << " * Automatically Generated by:\n";
    (*output) << " * Arjuna MultiServer Generator Version 1.0.0\n";
    (*output) << " *\n";
    (*output) << " * Do Not Edit By Hand\n";
    (*output) << " */\n\n";

    (*output) << "#include <System/iostream.h>\n";
    (*output) << "#include <Thread/Thread.h>\n\n";

    /*
     * The data structure we need to pass argc/argv to
     * the threads.
     */
    
    (*output) << "struct args\n";
    (*output) << "{\n";
    (*output) << "int argc;\n";
    (*output) << "char** argv;\n";
    (*output) << "};\n\n";

    /*
     * Now include the correct header files.
     */
    
    generateHeaders();

    (*output) << "\n";

    /*
     * Generate the thread code.
     */
    
    generateThreadBody();

    /*
     * Finally main. The main thread always runs the
     * last class we were given.
     */
    
    (*output) << "\nint main (int argc, char** argv)\n";
    (*output) << "{\n";
    (*output) << "args* data = new args;\n\n";

    (*output) << "data->argc = argc;\n";
    (*output) << "data->argv = argv;\n\n";

    generateThreadCall();

    (*output) << "\nThread::yield();\n\n";
    
    (*output) << classes[classIndex-1] << "Body(data);\n\n";

    (*output) << "return 0;\n";
    (*output) << "}\n";
    
    if (output)
	delete output;

    return 0;
}
