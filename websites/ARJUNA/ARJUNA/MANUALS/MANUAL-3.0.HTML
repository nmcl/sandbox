<HTML>

<HEAD>
<TITLE>Arjuna System Manual</TITLE>
</HEAD>

<BODY BGCOLOR="#FFFFFF">
<HR>

<PRE WIDTH=132>
                                                                       
Reliable                                                               
Distributed                                                            
Programming                                                            
in C++                                                                 


</PRE>
<HR>

<P>
<HR>

<PRE WIDTH=132>
                                                                      
                                                                      
                                                                      
                <B>The <I>Arjuna</I> System Programmer's Guide</B>                  

                         <B>Public Release 2.0</B>                           


</PRE>
<HR>

<P>

<PRE WIDTH=132>
                                                                     
                  Department of Computing Science,                   
                       Computing Laboratory,                         
                The University, Newcastle upon Tyne,                 
                            NE1 7RU, UK.                             


</PRE>

<P>
<B>Copyright Notice:</B>
<P>
<I>Copyright 1990, 1991, 1992, 1993, 1994<BR>
Computing Laboratory, University of Newcastle upon Tyne, UK. </I>
<P>
<I>Permission to use, copy, modify and distribute the </I>Arjuna<I>
software for evaluation, teaching and/or research purposes only
and without fee is hereby granted, providing that this copyright
and permission notice appear on all copies and supporting documentation,
and that similar conditions are imposed on any individual or organisation
to whom the program is distributed.</I>
<P>
<I>The University of Newcastle upon Tyne makes no representation
about the suitability of this software for any purpose. It is
provided &quot;as is&quot; without express or implied warranty.</I>
<P>
<B>Research Funding:</B>
<P>
<U>The <I>Arjuna</I> project began in 1985 and is now funded by
the UK Science and Engineering Research Council (SERC) grant No.
GR/F 06494: The Design of High Performance Distributed Fault-Tolerant
Systems, SERC grant No. GR/F 38402: Fault-Tolerant Multi-processor
Systems and ESPRIT Project 2267: Integrated Systems Architecture
(ISA) through a subcontract monitored by APM Ltd., Cambridge.</U>
<P>
<B>Research Staff Members:</B>
<P>
The <I>Arjuna</I> research effort has been, and continues to be
a team effort. As of January 1994, the project members are:
<P>
Prof. Santosh K. Shrivastava   (Santosh.Shrivastava@newcastle.ac.uk)
<BR>
Dr. Graham D. Parrington  (Graham.Parrington@newcastle.ac.uk)
<BR>
Dr. Stuart M. Wheater  (Stuart.Wheater@newcastle.ac.uk)<BR>
Dr. Mark C. Little   (M.C.Little@newcastle.ac.uk)<BR>
Mr. Steve J. Caughey   (S.J.Caughey@newcastle.ac.uk)<BR>
Mr. David Ingham   (Dave.Ingham@newcastle.ac.uk)<BR>
Mr. Luiz E. Buzato   (L.E.Buzato@newcastle.ac.uk)<BR>
Mr. Alcides Calsavara   (A.Calsavara@newcastle.ac.uk) <BR>
Mr. Raimundo J. D. A. Macedo (R.J.D.A.Macedo@newcastle.ac.uk)
<BR>
Mr. Jim Smith    (Jim.Smith@newcastle.ac.uk)
<P>
       <I>The </I>Arjuna<I> Research Group</I>
<P>
<I>       January, 1994.</I>
<P>
<B>Table of Contents</B>
<P>
Changes in Version 2.0 41. Introduction 51.1.  Failure Assumptions 61.2. The Object and Action Model of Computation 61.3. The Life-Cycle of an Object 71.4. Remote Operations 91.5. Replication 91.6. Object Clustering 101.7. Example 102. The Arjuna Programming Model 122.1. The Structure of the Arjuna Software 122.1.1. The Arjuna Class Hierarchy 122.1.2. The Object Store 132.1.2.1. The Persistent Object Store 132.1.2.2. The Volatile Object Store 132.1.3. The State Management Mechanism 142.1.4. Uids and Identifying Persistent Objects 142.1.5. The Concurrency Control Mechanism 142.1.6. The Atomic Action Mechanism 152.2. Arjuna from the Class Developer's View 152.2.1. State Management Issues 152.2.1.1. Constructors 162.2.1.2. ObjectState Management Issues 172.2.1.3. Example 182.2.1.4. Activating, Deactivating and Modifying Objects 192.2.2. Lock Management Issues 202.2.2.1. Miscellaneous LockManager Issues 212.2.3. Atomic Action Issues 212.2.3.1. Nested Actions 222.2.3.2. Example 232.3. Deleting Persistent Objects 242.3.1. Passive Objects 242.3.2. Active Objects 242.4. Atomic Actions within save_state and restore_state 252.5. Building a Simple Application 252.5.1. A Persistent Queue Class 262.5.1.1. Constructors and Destructors 272.5.1.2. Other Operations 282.5.2. Queue Using Atomic Actions 312.5.2.1. Constructors and Destructors 312.5.2.2. Other Operations 322.5.2.3. Comments 332.5.3. Queue as a Composite Object 343. Constructing Distributed Applications 373.1. The Stub Generator 373.1.1. Basic Use of the Stub Generator 383.1.2. Distributing the Queue 413.2. A Remotely Invocable Queue 413.2.1. Comments 433.3. An Internally Distributed Queue 433.3.1. Comments 454. Stub Generation Specifics 464.1. Introduction 464.2. Assumptions 464.3. Files, Directives and Options 464.3.1. Output Files 464.3.2. Directives 474.3.3. Command Line Options 484.4. Processing Caveats 484.5. Parameter Marshalling 494.5.1. Marshalling Classes 494.5.2. Marshalling Pointers and References 494.6. Limitations 504.7. Example 514.8. Local and Remote Instances 555. Advanced Programming Techniques 565.1. Nested Top-Level Atomic Actions 565.2. Naming Remote Persistent Objects 565.2.1. Class Interface Modifications 575.2.2. Creating a New Named Object (Locally) 575.2.3. Creating a New Named Object (Remotely) 575.2.4. Using An Existing Named Object 585.2.5. Implementation of the Naming Constructors 585.3. Changing Timeout Values 585.4. Persistent Object Constructors 595.4.1. Server-Side Action 595.4.2. Client-Side Action 595.4.3. Non-Action Constructor 605.4.4. Saving the State of a New Persistent Object 605.5. The Interface Browser 605.5.1. Registering Interfaces. 615.5.2. Obtaining Interfaces. 616. Object Replication 636.1. Basic Replication Concepts 636.1.1. Replication Protocols 636.2. Replication in Arjuna 646.3. Replicating a Persistent Object 656.4. The Name Server 666.5. The GroupView Database 676.5.1. Creating Group Views 676.5.2. Excluding Group Members 686.5.3. Failure Masking 686.6. HasRemoteState Operation 686.7. Registering new replica groups 696.8. Example 706.9. Replicating the Name Server and GroupView Database 737. Object Clustering 758. Notes on Program Structuring and Debugging 768.1. General 768.1.1. Server 768.1.2. Client 768.2. When Things Go Wrong 778.2.1. The Client Startup 778.2.2. Shared Memory and Semaphore Recovery 778.2.3. Server Request Failures 788.3. General Debugging 788.4. Object Persistence and Object States 798.5. Arjuna Debugging 798.5.1. User Class Diagnostics 828.5.2. Other Useful Utilities 829. Crash Recovery 849.1. Crash Detection and Recovery 849.1.1. Orphans and Deadlines 849.1.2. Recovering from a Crash 859.1.2.1. The Recovery Daemon 859.1.2.2. The Recovery Manager 859.1.2.3. The AtomicAction directory 869.1.2.4. The ServerAtomicAction directory 8610. The ObjectStore Class 8710.1. Persistent Object Store 8710.2. The Volatile Object Store 8811. Arjuna Services and Tools 9012. Arjuna System Components 9112.1. Overview of the Arjuna Structure 9112.2. The Name Server 9212.3. RPC Module 9212.3.1. At the Client 9312.3.2. At the Server 9412.4. Object Store 9512.5. Object-Action 9512.6. Execution of an Application 95Appendix A: Installation 100A.1 Loading the Sources 100A.2 System Configuration 101A.3 Building and Installing the Software 101A.4 Preparing Your System 102A.5 Booting the Arjuna Run-Time System 103A.6 Administration of Arjuna 104Appendix B: Class Library 106B.1 ObjectState 106B.2 StateManager 106B.3 Buffer 107B.4 Uid 109B.5 LockManager 109B.6 AtomicAction 110B.7 ClientRpc 111B.8 RpcControl 111B.9 ArjunaName 112ObjectStore Class 112B.10 Debug Class 113Appendix C: A Glossary of Arjuna Classes 117Appendix D: Arjuna Papers 121<B>Preface</B>
<P>
This manual describes the structure and use of the <I>Arjuna</I>
system. <I>Arjuna </I>is a research software system that provides
several tools and facilities for the development of reliable,
distributed C++ programs. This manual is structured so that a
user unfamiliar with <I>Arjuna </I>should be able to write and
test non-distributed applications after reading only the first
two chapters. Subsequent chapters cover distributing applications
and the various tools provided in much greater detail; the reader
who works through them should emerge with a thorough practical
understanding of the system and how to use it. If more details
are required, the interested reader is referred to the publications
list at the end of this document.
<P>
The structure of this manual is as follows:
<P>
<B>Changes in Version 2.0: </B>A brief description of the changes
which have occurred between version 1.2 and version 2.0.
<P>
<B>Chapter 1. Introduction: </B>An introduction to, and brief
overview of, the <I>Arjuna </I>system, focusing on some of the
key issues and terminology.
<P>
<B>Chapter 2. The <I>Arjuna</I> Programming Model: </B> A tutorial
on writing non-distributed, fault-tolerant applications using
the <I>Arjuna </I>programming tools.
<P>
<B>Chapter 3. Constructing Distributed Applications: </B>Details
of how to write distributed applications.
<P>
<B>Chapter 4. Stub Generation Specifics:</B> A more in depth look
at using the stub generation tool for writing distributed applications.
<P>
<B>Chapter 5. Advanced Programming Techniques: </B>Details of
how to write more advanced applications.
<P>
<B>Chapter 6. Object Replication: </B>A description of the replication
protocols used by <I>Arjuna</I> and how to write applications
to take advantage of them.
<P>
<B>Chapter 7. Object Clustering:</B> A description of the object
clustering (configuration) mechanism available to application
programmers.
<P>
<B>Chapter 8. Notes on Program Structuring and Debugging:</B>
Some guide-lines and recommendations that should be followed when
writing applications, including some hints for debugging such
applications.
<P>
<B>Chapter 9. Action Management and Crash Recovery: </B>A description
of how <I>Arjuna </I>achieves its fault-tolerance.
<P>
<B>Chapter 10. The ObjectStore Class: </B>More details on the
main object store classes used by <I>Arjuna</I>.
<P>
<B>Chapter 11. <I>Arjuna</I> Services and Tools: </B>Details of
services and tools available for aiding in writing distributed
applications, converting objects created using old versions of
<I>Arjuna</I> to the new system, etc.
<P>
<B>Chapter 12. <I>Arjuna</I> System Components: </B>A more in
depth discussion on the various components that make up <I>Arjuna</I>.
<P>
<B>Appendix A. Installation: </B>A description of how to build
and install the <I>Arjuna </I>system.
<P>
<B>Appendix B. User Classes:</B> A quick reference to those <I>Arjuna</I>
classes that a programmer will most typically use.
<P>
<B>Appendix C. A Glossary of <I>Arjuna</I> Classes: </B>A brief
description of the classes in <I>Arjuna</I>.
<P>
<B>Appendix D. <I>Arjuna</I> Papers: </B>A bibliography of the
<I>Arjuna</I> papers.
<P>
The present version of the <I>Arjuna </I>system supports nested
(sequential) atomic actions that can control operations on objects
(instances of C++ classes). Remote objects are accessed transparently
by the use of the stub generation tool. <I>Arjuna</I> supports
both active and passive replication to improve the availability
of objects in the presence of failures. In addition, objects can
be clustered dynamically to improve the performance of applications
which used them.
<P>
The system has been ported to various platforms, including the
following:
<P>
 (i) HP workstations running HPUX;<BR>
(ii) Sun 3, Sun 4, Sun Sparc, running SunOS 4 and 5 (Solaris);
<BR>
(iii) RS6000 machines running AIX;<BR>
(iv) Intel 486 PCs running Linux.
<P>
The system has been tested with various C++ compilers including:
CFront (2.1 to 3.0.1), g++ (2.1 to 2.5), xlC, HP's C++ compiler,
Sun's C++ compiler.
<P>
A commercial version of <I>Arjuna</I> on ANSAware is available
from APM Ltd. Commercial use of the standard <I>Arjuna</I> system
is possible: interested parties should contact Professor Santosh
Shrivastava.
<P>
We are making available the <I>Arjuna</I> systems software to
researchers, system designers and teachers for research and teaching
purposes.
<P>
Technical Questions  Arjuna@newcastle.ac.uk<BR>
Information Service  Arjuna-Info@newcastle.ac.uk<BR>
Information Service Admin Arjuna-Info-Admin@newcastle.ac.uk
<P>
The <I>Arjuna</I> Info Service is a simple information retrieval
system that is accessed via electronic mail. The Information Service
has information about many topics related to the <I>Arjuna</I>
System. The information on a particular topic can be obtained
by sending a message whose &quot;Subject:&quot; line is the topic
you are interested in. For a complete list of all the topics,
ask for &quot;index&quot;.
<P>
Papers and further information about <I>Arjuna</I> is also available
via anonymous ftp from arjuna.ncl.ac.uk (currently 128.240.150.1).
The user's attention is drawn to the copyright notice pertaining
to the use of the system.
<H2>Changes in Version 2.0</H2>

<P>
The following changes have been made to the latest version of
<I>Arjuna</I>, excluding bug fixes and general code maintenance.
These changes will be described in detail in later chapters:
<P>
 The <I>Arjuna</I> object store has been modified to significantly
improve its write performance. These modifications have resulted
in the fact that object states (the compact representations of
objects that are actually stored in the Object Store) are no longer
stored as simple byte streams. This has several consequences,
amongst which is the fact that object state files can no longer
be simply copied around the system (or between nodes) using standard
UNIX commands; furthermore the new release of <I>Arjuna</I> will
not function correctly with the old object state files. However,
as will be described later, several application tools have been
provided to overcome these difficulties.
<P>
 the format of the Uid has been changed to improve the overall
system performance. The current system still accepts old-style
Uids at creation time, but automatically converts them to the
new format. Object states named with the old format Uid must be
renamed to the new format. The <TT>UidConverter</TT> utility has
been provided for this.
<P>
 nested top-level atomic actions have been implemented, allowing
non-serialisable effects from within (deeply) nested atomic actions.
<P>
 a new object replication scheme has been added (this includes
the ability to replicate <I>complex</I>, or <I>composite</I>,
objects). This has resulted in a new naming scheme, although backward
compatibility has been retained.
<P>
 (dynamic) object configuration has been included, allowing objects
to be associated with each other to improve system performance.
<P>
 a new crash recovery mechanism has been implemented, taking into
account replication.
<P>
 the suite of tests for the system has been upgraded to take these
changes into account.
<P>
 remote objects (servers) can be shared between different clients,
with certain restrictions.
<P>
 the directory structure of <I>Arjuna</I> has changed in the full
2.0 release to improve the logical layout. This means that the
locations of various files (e.g., user header files) and binaries
has been altered.
<H1>Introduction</H1>

<P>
The <I>Arjuna</I> system provides tools that help in the construction
of fault-tolerant applications structured as <I>atomic actions</I>
operating upon <I>persistent objects</I>. The system is implemented
in C++ and extensively uses the type-inheritance facilities provided
by the language to provide user-defined objects with characteristics
such as persistence and recoverability.
<P>
<I>Note: At present Arjuna does not support the multiple-inheritance
facilities provided by C++.</I>
<P>
<I>Arjuna</I> is an object-oriented programming system that provides
a set of tools for the construction of fault-tolerant distributed
applications. <I>Arjuna</I> provides nested atomic actions (nested
atomic transactions) for structuring application programs. Atomic
actions operate on objects, which are instances of abstract data
types (C++ classes), by making use of remote procedure calls (RPCs).
In <I>Arjuna</I>, objects are regarded as long lived (persistent)
entities and are the main repositories for application state.
<P>
The computational model of atomic actions controlling operations
upon objects provides a natural framework for incorporating integrated
mechanisms for fault-tolerance and distribution. In <I>Arjuna</I>,
these mechanisms have been provided through a number of C++ classes;
these classes have been organised into a class/type hierarchy
in a manner which will be familiar to the developers of 'traditional'
(single node) centralised object-oriented systems. <I>Arjuna</I>
is novel with respect to other fault-tolerant distributed systems
in taking the approach that every major entity in the system is
an object. Thus, <I>Arjuna</I> not only supports an object-oriented
model of computation, but its internal structure is also object-oriented.
<P>
The design and implementation goal of <I>Arjuna </I>was to provide
a state-of-the-art programming system for constructing fault-tolerant
distributed applications. In meeting this goal, three system properties
were considered highly important:
<P>
 <I>Integration of Mechanisms.</I> A fault-tolerant distributed
system requires a variety of system functions for naming objects,
locating and invoking operations upon objects and also for concurrency
control, error detection and recovery from failures. These mechanisms
must be integrated such that their use by a programmer is easy
and natural.
<P>
 <I>Flexibility.</I> These mechanisms must be flexible, permitting
application specific enhancements, such as type-specific concurrency
and recovery control, to be easily produced from existing defaults.
<P>
 <I>Portability.</I> The system must be easy to install and run
on a variety of hardware configurations.
<P>
The computational model provided by atomic actions controlling
operations upon objects provides a natural framework for incorporating
integrated mechanisms for fault-tolerance and distribution. In
<I>Arjuna</I>  these mechanisms have been provided through several
C++ classes. Furthermore, every major entity of  the system is
also an object. Thus, the system not only supports an object-oriented
model of computation, but its internal structure is also object-oriented.
<P>
This section presents a brief overview of the <I>Arjuna</I> system,
 identifying the major system components and how they interact.
A brief review of the object and action model supported by <I>Arjuna</I>
follows. For a more detailed description of the components that
constitute <I>Arjuna</I> see<U><B> chapter 7</B></U>.
<H2>   Failure Assumptions</H2>

<P>
It is assumed that the hardware components of the system are workstations
(nodes), connected by a communication sub-system (for example,
a local area network). A node is assumed to work either as specified
or simply to stop working (crash). After a crash a node is repaired
within a finite amount of time and made active again. A node is
assumed to have both stable and non-stable (volatile) storage.
All the data stored on volatile storage is assumed to be lost
when a crash occurs; any data stored on stable storage, as stated
earlier, remains unaffected by a crash. It is also assumed that
the faults in the communication sub-system are responsible for
failures such as lost, duplicated or corrupted messages. The RPC
system is assumed to be responsible for coping with such failures
using well-known network protocol level techniques.
<H2>  The Object and Action Model of Computation</H2>

<P>
One computational model that has been widely advocated for constructing
robust distributed systems is based upon the concepts of <I>atomic
actions</I> controlling operations upon <I>persistent objects</I>.
An object is an instance of some type or class (we use the terms
<I>type</I> and <I>class</I> interchangeably). Each individual
object consists of some variables (its <I>instance</I> variables)
and a set of operations (its <I>methods</I>) that determines the
externally visible behaviour of the object. The operations supported
by an object have access to the instance variables and can thus
modify its  internal state. It is assumed that the invocation
of any of these operations produces consistent (class specific)
state changes to the objects in the system in the absence of failures.
In a distributed system, operations upon remote objects are typically
invoked via remote procedure calls (RPCs), that use messages for
passing parameters to the operation and returning any results
back to the caller.
<P>
Such operation invocations may be controlled by atomic actions
that have the following properties: 
<P>
 <I>Serialisability</I>: This property ensures that the concurrent
execution of programs that access common objects is free from
interference (i.e., the concurrent execution can be shown to be
equivalent to some serial order of execution). Some form of concurrency
control policy, such as that enforced by two-phase locking, is
required to ensure this property of actions.
<P>
 <I>Failure Atomicity</I>: This property ensures that a computation
can either be terminated normally (<I>committed</I>), producing
the intended results or it can be <I>aborted</I> producing no
results. This latter property may be obtained by the appropriate
use of backward error recovery, that is invoked whenever a failure
that cannot be masked occurs. Typical failures causing a computation
to be aborted include node (workstation) crashes and communication
failures such as the continued loss of messages.
<P>
 <I>Permanence of Effect:</I> It is reasonable to require that
once a computation terminates normally, the results produced are
not destroyed by subsequent node crashes. This is met by this
third property that ensures that any state changes produced (i.e.,
the new states of all objects modified within the action) are
recorded on stable storage, a type of storage that can survive
node crashes with high probability. A commit protocol is required
during the termination of an action to ensure that either all
the objects updated within the action have their new states recorded
on stable storage (committed), or no updates get recorded (aborted).
<P>
This object and action model provides a natural framework for
designing fault-tolerant systems supporting persistent objects,
and is employed in <I>Arjuna</I>. Persistent objects normally
reside in object stores that are required to be stable. Atomic
actions are employed to control the state changes to these objects
and the properties of atomic actions given above ensure that only
consistent state transformations take place on objects, despite
failures.
<P>
Each object normally resides on a single node in an object store,
however, the availability of an object can be increased by replicating
it on several nodes and thus storing it in more than one object
store. Such replicated objects must be managed through appropriate
replica-consistency protocols to ensure that the object copies
remain mutually consistent. Such protocols can be integrated within
action based systems, as has been done in <I>Arjuna</I>. Replication
will be considered in more detail later in this chapter.
<H2> The Life-Cycle of an Object</H2>

<P>
Every persistent object in <I>Arjuna</I> has a &quot;home node&quot;
where it normally resides in a <I>passive state</I> in a (stable)
<I>object store</I>. An object is made <I>active </I>by loading
the passive state from the object store into the home node's primary
memory. Once activated, an object stays that way until made <I>passive</I>:
when a top-level action commit occurs, the current state of the
object is forced back to the stable store automatically (i.e.,.
the object is made passive). The object store representation of
an object may differ from its volatile store representation (e.g.,
pointers may be represented as offsets or object identifiers).
<I>Arjuna</I> assumes that an object is responsible for providing
the relevant state transformation operations that enable its state
to be stored and retrieved from the object store.
<P>
The programmer need only modify the code of an application slightly
when calling operations of persistent (remote) objects. In particular
the programmer needs to provide implementations of the operations
invoked by the system for saving and restoring the object's state
(called <I>save_state</I> and <I>restore_state</I>). Furthermore,
to ensure that conflicting operations cannot occur on the same
object simultaneously and to preserve the serialisability property
of atomic actions, the programmer must set locks (read locks and
write locks) using the <I>setlock</I> operation.
<P>
During its life time, a persistent object may be made active then
passive often, as illustrated by figure 1.1.
<P>
<B>Figure 1.1: The Life Cycle of a Persistent Object</B>
<P>
In <I>Arjuna</I>, a user object must be converted into an instance
of class <TT>ObjectState</TT> before it can be stored in the object
store (this conversion is performed by the <TT>save_state </TT>operation).
Internally an <TT>ObjectState</TT> object is really an array of
bytes, so is suitable for disk storage. When an object is made
active, the instance of the class <TT>ObjectState</TT> is retrieved
from the object store, and loaded into an instance of the user
object (using the <TT>restore_state</TT> operation provided by
the implementor of the user object). Operations may now be performed
on the object.
<H2>  Remote Operations</H2>

<P>
If the object is remote from the invoker (client) node then it
is necessary it make use of the remote procedure call mechanism
(RPC) to be able to invoke the relevant operations. To be able
to do this it is necessary to associate a process with the remote
object which will be responsible for receiving such client requests,
passing them on to the actual object, and transmitting the results
back to the client. The RPC primitive operation <I>initiate </I>is
used to create a server process for that object to execute operation
invocation requests (a well-known <I>manager process </I>on every
node is responsible for creating servers). A complimentary operation
to <I>initiate</I>, called <I>terminate</I>, is available for
destroying the associated server process.
<P>
The task of locating a (passive) object and activating it has
been automated by a C++ Stub Generation System that also performs
parameter marshalling and all the other functions necessary for
making RPCs. By making use of this Stub Generator tool <I>Arjuna</I>
achieves access and location transparency, i.e., invocations on
a remote object are written in the same way as local object invocations.
The stub code generates the necessary calls on <I>initiate</I>
and <I>terminate</I> as an object comes and goes out of scope
of a computation.
<P>
As we shall see later, because exception handling in C++ is not
generally available, it is necessary to program in a slightly
&quot;defensive&quot; manner when making use of remote objects.
The stub generation mechanism makes such object invocations transparent
and if they fail (for example, the remote node is unavailable)
it is necessary to provide some indication of this to the application
code which made the original call. Until the arrival of exception
handling, it is common <I>Arjuna</I> practice for all object methods
(including constructors) to have an extra &quot;dummy&quot; parameter
which the remote object will set to some value if the call is
successful. By checking this parameter whenever an object method
returns, it is possible to determine if the call was successful
and whether any data returned can be used.
<H2>  Replication</H2>

<P>
Application programmers make use of atomic actions to control
operations on objects. Atomic actions guarantee that despite failures
the state of objects will remain consistent. However, forward
progress is not guaranteed: if an object fails during an action,
the action must abort. To enable applications to progress despite
(a finite number of) failures, <I>Arjuna</I> supports active and
passive replication. If an object is replicated, forming a <I>replica
group</I>, then as long as at least one member of the group is
available the atomic action can commit.
<P>
The <I>Arjuna</I> object model is one of method and state separation:
the object's methods are instantiated and, if it possesses a persistent
state, the state is loaded from/written to the object store when
required. This provides a natural framework in which to build
object replication protocols: the methods and state can be replicated
independently, providing the ability to support all types of replication
protocol. The current default protocol supported by <I>Arjuna</I>
is that of single-copy passive replication: a single copy of the
object's methods are instantiated and this interacts with (possibly)
multiple copies of the object's state. The object life cycle given
above remains exactly the same in this replication scheme with
the exception that the object store interactions are <I>possibly</I>
replicated. The scheme is optimised for read transactions: a single
copy of the object's state is read from, whereas all available
copies are written to.
<H2> Object Clustering</H2>

<P>
&lt;Stuart to supply a brief description of why this is required
and how it is achieved - a couple of paragraphs&gt;
<H2> Example</H2>

<P>
The simple example below illustrates the relationships between
activation, termination and commitment:
<PRE>
{
	.......
	O1 objct1(Name-A);			/* bind to &quot;old&quot; persistent object A */
	O2 objct2;					/* bind to &quot;new&quot; persistent object */
	AtomicAction act;

	act.Begin();				/* start of atomic action */
	objct1.op(...);			/* object activation and invocations */
	objct2.op(...);
	........
	act.End();					/* action commits */
								/* objects deactivated */

}								/* break bindings to objects */
</PRE>

<P>
The execution of an <I>Arjuna</I> atomic action thus involves
the following sequence of activities (as we shall see later, variations
on this sequence are possible):
<P>
(i) creation of bindings to persistent objects; this could involve
the creation of stub objects and a call on <I>initiate</I> for
remote objects. In the above example we re-bind to an &quot;old&quot;
persistent object identified by <TT>Name-A</TT> (one which was
created previously, and whose state resides in the object store),
and a new persistent object. A naming system for remote objects
(discussed further in <U><B>chapter 6</B></U>) maintains the mapping
between object names and locations (host names).
<P>
(ii) start of the atomic action;
<P>
(iii) method invocations: as a part of a given invocation the
object will be locked in read or write mode (assuming no lock
conflict), and initialised, if necessary, with the latest committed
state from the object store. The first time a lock is acquired
on an object within an atomic action the object's state is acquired,
if possible, from the object store.
<P>
(iv) commit/abort of the action;
<P>
(v) breaking of the previously created bindings. For remote objects,
this involves a call on <I>terminate</I> by the stub code.
<P>
The variable <TT>Name-A</TT> passed to the constructor of <TT>objct1</TT>
is used to uniquely identify the object. This can either be an
instance of the class <TT>Uid</TT>, or an instance of the class
<TT>ArjunaName</TT>.
<H1> The <I>Arjuna</I> Programming Model</H1>

<P>
This section contains a description of the tools provided by the
<I>Arjuna</I> system for the construction of non-distributed applications
using atomic actions. The classes mentioned in this section are
the key to writing fault-tolerant applications with <I>Arjuna</I>.
Thus, after describing these tools we shall apply them in the
construction of a simple, non-distributed application.
<H2> The Structure of the <I>Arjuna</I> Software</H2>

<P>
In keeping with the object-oriented view, the mechanisms needed
to construct reliable distributed applications are presented to
users in an object-oriented manner. Both atomic actions and locks
are objects, that can be manipulated using their operations like
any other object. If the designer of a class decides that the
objects of that class need to be persistent, recoverable, or concurrency
controlled, then the class may acquire these properties by inheriting
them from the appropriate class provided by <I>Arjuna</I>, with
very minor changes to the original class.
<P>
The possibility that the objects are located on different nodes
is made transparent to the user application by a stub generation
tool. The stub generator produces code that enables the operations
of an object to be invoked by a user application even if the object
and application are on different nodes. The client stub code generated
by the stub generator performs operations on remote objects through
an RPC mechanism. These aspects will be described in more detail
in the next chapter.
<H3> The <I>Arjuna</I> Class Hierarchy</H3>

<P>
The diagram in figure 2.1 shows the class hierarchy of the system.
All of the classes are derived from the base class <TT>StateManager</TT>,
that provides an interface to the state management mechanism.
This means that instances of all the classes in the hierarchy
can be stored in the object store. The user-defined classes that
are accessed using atomic actions, must be derived from class
<TT>LockManager</TT>. The class <TT>LockManager</TT> provides
standard two-phase locking facilities. The class <TT>Lock</TT>
provides the well known multiple-reader/single-writer locking
policy.
<P>
<B>Figure 2.1 : The Arjuna Class Hierarchy</B>
<H3> The Object Store</H3>

<P>
To manage the states of persistent objects stored at a node, the
system provides a class called <TT>ObjectStore</TT>, an instance
of which can be used to manipulate the object store on that node.
In the distributed environment, each node in the network possesses
it own object store. There are currently two types of object store
available to <I>Arjuna</I> objects: a disk based object store,
and an in-memory based version.
<H4> The Persistent Object Store</H4>

<P>
The current implementation of the persistent, disk-based object
store makes use of the UNIX file system as a stable store, and
it is assumed to survive crashes (that is, file information not
resident in the volatile store will not be affected by a crash).
The states of each persistent object are stored in individual
files that are divided into directories depending on the class
of the object. The directory name in which the state of a persistent
object resides is determined by the name of the class and the
names of the classes it inherits. For example, the objects of
a user defined class <TT>SpreadSheet</TT> derived from class <TT>LockManager</TT>
would be stored in the directory <TT>StateManager/LockManager/SpreadSheet</TT>
within the <TT>ObjectStore</TT> directory.
<H4> The Volatile Object Store</H4>

<P>
From release 1.2 an in-memory, volatile object store has been
added to the system, allowing shared recoverable objects. This
makes use of UNIX System V shared memory, and the object store
exists for as long as a reference to it exists within the system.
Likewise, object states stored in this memory segment exist for
as long as the segment exists, or until they are explicitly deleted.
Although primarily intended for recoverable objects (since a machine
failure will result in the loss of states), a persistent store
can be approximated using this mechanism.
<H3> The State Management Mechanism</H3>

<P>
<I>Arjuna</I> provides <I>state-based</I> recovery for persistent
and recoverable objects. The state management mechanism implemented
by <TT>StateManager</TT> provides support for the use of both
<I>persistent</I> and <I>recoverable</I> objects. A process can
load the state of an existing persistent object into an instance
of the object's class. If required it can save a new state of
the object back into the object store. The state management mechanism
also enables the implementation of simple recoverable objects,
allowing modifications to both persistent and non-persistent objects
to be undone.
<P>
If the implementor of a class decides that the objects of that
class need to be either persistent or recoverable, then this can
be simply achieved by the class inheriting from the class <TT>StateManager</TT>.
The implementor then needs to provide operations to save and restore
the state of the object.
<H3> Uids and Identifying Persistent Objects</H3>

<P>
All objects within <I>Arjuna</I> derived from the class <TT>StateManager</TT>
are named by an identifier which is guaranteed to be unique across
machine boundaries (an instance of the class <TT>Uid</TT>). The
state of a persistent object is stored in a UNIX file in the object
store, and the file is identified by the object's <TT>Uid</TT>.
When a persistent object is created it can be identified and used
by a later application, or action, by giving its <TT>Uid</TT>
at object re-creation time. Instances of the class <TT>Uid</TT>
can be stored in the state of a persistent object for later use
by making use of the <TT>pack</TT>/<TT>unpack</TT> operations
of the class.
<P>
The format of a <TT>Uid</TT> is a combination of the internet
address of the machine on which it was created and three unsigned
long integers representing the time at which it was created and
the process which created it.
<P>
In previous version of <I>Arjuna</I>, the <TT>Uid</TT> was represented
in decimal format. However, from version 2.0 the format has been
changed to hexadecimal representation to improve performance.
The <TT>Uid</TT> class can still be supplied with old-style <TT>Uid</TT>
representations and automatically converts them to the new format.
However, object states which were named with the original format
must be renamed to the new format in order for them to be used.
The <TT>UidConverter</TT> utility has been provided for this.
<H3> The Concurrency Control Mechanism</H3>

<P>
The concurrency control mechanism provides support for traditional
multiple reader, single writer locking, thus ensuring that only
one action is modifying an object at any one time, and ensuring
that an object is not being modified by one action while it is
being inspected by another. If the implementor of a class decides
that the member operations require concurrency control, then this
can be simply achieved by the class inheriting the class <TT>LockManager</TT>.
The implementor then acquires (and releases) locks by making suitable
calls to the underlying mechanism within the class code.
<H3> The Atomic Action Mechanism</H3>

<P>
The atomic action mechanism co-ordinates the state management
and concurrency control mechanisms and provides operations to
begin a new atomic action, end the current atomic action, or to
abort the current atomic action. Atomic actions can be nested,
and independent top-level actions can be started within nested
atomic actions, although this can result in non-serialisable behaviour.
<P>
In <I>Arjuna</I> atomic actions are provided by instances of the
class <TT>AtomicAction</TT>. Atomic actions are begun, committed
and aborted, by calling operations on these objects (<TT>begin</TT>,
<TT>end</TT>, and <TT>abort</TT> respectively).
<H2> <I>Arjuna</I> from the Class Developer's View</H2>

<P>
As we shall see, there are two distinct phases to the development
of an <I>Arjuna</I> application:
<P>
1. Developing new classes with certain characteristics (for example,
Persistent, Recoverable, Concurrency Controlled).
<P>
2. Developing the application(s) that make use of the new classes
of objects.
<P>
Although these two phases may be performed in parallel and by
a single person, we shall refer to the first step (i) as the job
of the <I>class developer</I> and the second (ii) as the job of
the <I>applications developer</I>. The class developer will be
concerned about defining appropriate <TT>save_state</TT> and <TT>restore_state</TT>
operations for the class, setting appropriate locks, etc. The
applications developer will be more concerned with defining the
general structure of the application, particularly with regards
to the use of atomic actions and distribution.
<H3> State Management Issues</H3>

<P>
The <I>Arjuna </I>class that manages the state of an object is
called <TT>StateManager</TT>. This class provides all the basic
support mechanisms required by an object for state management
purposes. Those operations that must be defined by the programmer
are declared as C++ pure virtual functions. 
<P>
Following is the relevant part of the <TT>StateMan.h</TT> header
file:
<PRE>
enum ObjectType { RECOVERABLE, ANDPERSISTENT, NEITHER };

class StateManager
{
public:
	Boolean activate(ObjectStore* = 0);
	Boolean deactivate(ObjectStore* = 0, Boolean = TRUE);
	const Uid&amp; get_uid() const;
	. . .
	virtual Boolean save_state(ObjectState&amp;, ObjectType) = 0;
	virtual Boolean restore_state(ObjectState&amp;, ObjectType) = 0;
	virtual const TypeName type () const = 0;

protected:
	StateManager(ObjectType ot = RECOVERABLE,
				  Boolean shared = FALSE);
	StateManager(const Uid&amp; objUid,
				  ObjectType ot = ANDPERSISTENT);
	virtual ~StateManager();

	void modified();
	virtual void terminate();

private:
	. . .
};
</PRE>

<P>
Internally all naming of objects by the state management mechanism
is performed using unique identifiers. The unique identifier for
an object can only be set when the object is created and can be
determined via the <TT>get_uid</TT> operation. If the object is
new then <I>Arjuna</I> assigns a <TT>Uid</TT> for it, otherwise
one must be provided by the creator in order for the system to
be able to locate its state in the object store.
<H4> Constructors</H4>

<P>
<TT>StateManager</TT> provides two <I>protected</I> constructors
for use by derived classes, each of which fulfils a distinct purpose:
<P>
(i) <TT>StateManager(const Uid&amp; objUid, ObjectType ot = ANDPERSISTENT)</TT>:
this is provided to allow access to an <I>existing</I> persistent
object, by passing the unique identifier of the object as a parameter
via the user-defined class constructor. Objects constructed using
this method can have their prior state (identified by <TT>objUid</TT>)
loaded from the object store either automatically by the system
or explicitly via the use of the operation <TT>activate</TT>.
If the parameter <TT>ot</TT> is <TT>ANDPERSISTENT</TT> then the
disk-based object store is used, otherwise the in-memory store
is used to maintain the state.
<P>
(ii) <TT>StateManager (ObjectType ot = RECOVERABLE, Boolean shared
= FALSE)</TT>: this constructor allows the creation of new objects
(no state currently exists in the object store). By setting the
<TT>ObjectType</TT> parameter to <TT>ANDPERSISTENT</TT> the state
of the object will be stored on disk. The <TT>shared</TT> parameter
only has meaning if <TT>ot</TT> is <TT>RECOVERABLE</TT>; if <TT>shared</TT>
is <TT>FALSE</TT> then the recoverable state of the object is
maintained by the object (i.e., it has no external representation),
otherwise the in-memory (volatile) object store is used to store
the state of the object between atomic actions. A call to <TT>deactivate</TT>
(explicit or implicit) will place the current state of the object
in the object store.
<H4> ObjectState Management Issues</H4>

<P>
The persistence and recovery mechanisms implemented by <TT>StateManager</TT>
require that user-defined objects be converted into (from) instances
of the class <TT>ObjectState</TT>, in order that the state can
be placed in to the relevant object store. This conversion is
performed by the operations <TT>save_state</TT> and <TT>restore_state</TT>
that must be provided by the class developer. To aid in this conversion
process a set of pack (unpack) operations are provided by <TT>ObjectState
</TT>(in reality these are actually provided by the <TT>Buffer</TT>
class, from which <TT>ObjectState </TT>is derived). Basic pack
and unpack operations are provided for all the standard C++ types:
<PRE>
class Buffer
{
public:
	Boolean pack (const char);
	Boolean pack (const unsigned char);
	Boolean pack (const int);
	Boolean pack (const unsigned int);
	Boolean pack (const long);
	Boolean pack (const unsigned long);
	Boolean pack (const short);
	Boolean pack (const unsigned short);
	Boolean pack (const float);
	Boolean pack (const double);
	Boolean pack (const char *);			  // null terminated string
	Boolean pack (const char *, const size_t); // contiguous block of
												 // memory

	Boolean unpack (char&amp;);
	Boolean unpack (unsigned char&amp;);
	Boolean unpack (int&amp;);
	Boolean unpack (unsigned int&amp;);
	Boolean unpack (long&amp;);
	Boolean unpack (unsigned long&amp;);
	Boolean unpack (short&amp;);
	Boolean unpack (unsigned short&amp;);
	Boolean unpack (float&amp;);
	Boolean unpack (double&amp;);
	Boolean unpack (char*&amp;, Boolean = FALSE);
	Boolean unpack (char*&amp;, size_t&amp;);
}
</PRE>

<P>
 In addition, the persistence mechanism requires an implementation
of the <TT>type</TT> operation that indicates where the object
should be saved in the object store. Below is an example of the
structure of a type operation.
<PRE>
const TypeName RecObj::type() const { return &quot; . . . /RecObj&quot;; }
</PRE>

<P>
The string that is returned will depend on the classes from which
the class <TT>RecObj</TT> is derived. For example, the returned
string would be &quot;<TT>StateManager/RecObj</TT>&quot;, if <TT>RecObj</TT>
was derived from <TT>StateManager</TT>, and would be &quot;<TT>/StateManager/LockManager/RecObj</TT>&quot;
if <TT>RecObj</TT> was derived from <TT>LockManager</TT>.
<H4> Example</H4>

<P>
Consider the following basic <TT>Array</TT> class derived from
the <TT>StateManager</TT> class (in this example, to illustrate
saving and restoring of an object's state, the <TT>numberOfElements</TT>
variable is used to keep track of the number of non-zero values):
<PRE>
class Array : public StateManager
{
public:
	Array ();
	Array (const Uid&amp; objUid);
	~Array ();

	/* Class specific operations. */

	Boolean set (int index, int value);
	Boolean get (int index, int&amp; value);

	/* State management specific operations. */

	Boolean save_state (ObjectState&amp; os, ObjectType ot);
	Boolean restore_state (ObjectState&amp; os, ObjectType ot);
	const TypeName type () const;

private:
	int elements[ARRAY_SIZE];
	int numberOfElements;
};
</PRE>

<P>
The <TT>save_state</TT>, <TT>restore_state</TT> and <TT>type</TT>
operations can be defined as follows:
<PRE>
Boolean Array::save_state (ObjectState&amp; os, ObjectType)
{
	Boolean result = TRUE;

	/*
	 * Traverse Array state that we wish to save. Since we
	 * can regenerate numberOfElements at any time, we will
	 * not save this.
	 */

	for (int i = 0; ((i &lt; ARRAY_SIZE) &amp;&amp; (result)); i++)
		result = os.pack(elements[i]);

	return result;
}
Boolean Array::restore_state (ObjectState&amp; os, ObjectType)
{
	Boolean result = TRUE;

	/*
	 * Recreate the numberOfElements variable as we restore
	 * the state.
	 */

	numberOfElements = 0;
	for (int i = 0; ((i &lt; ARRAY_SIZE) &amp;&amp; (result)); i++)
	{
		result = os.unpack(elements[i]);
		if ((result) &amp;&amp; (elements[i] != 0))
			numberOfElements++;
	}

	return result;
}
const TypeName Array::type () const
{
	return &quot;/StateManager/Array&quot;;
}
</PRE>

<H4> Activating, Deactivating and Modifying Objects</H4>

<P>
If the implementor of a class wishes instances of the class to
be persistent or recoverable, then this can be achieved by deriving
the class from the <I>Arjuna </I>class <TT>StateManager</TT>.
<P>
If the internal state of an object is modified by one of its operations,
the <TT>modified</TT> operation must be called prior to the actual
state modification. This informs the state management mechanism
that a snapshot of the old state needs to be saved for recovery
purposes or that a new state of the object must be saved when
the object becomes passive. Since the <TT>modified</TT> operation
is <I>protected</I> then only the object itself can indicate that
it has been modified.
<P>
<I>Note</I>: since <TT>modified</TT> makes used of<TT> save_state</TT>
it is necessary to ensure that the object's state variables are
legal before it is called, e.g., that pointers have been set.
<P>
The <TT>activate</TT> and <TT>deactivate</TT> operations are used
to inform the state management mechanism that an object should
be made active or passive, respectively. This could result in
the calling of the <TT>save_state</TT> and <TT>restore_state</TT>
operations.
<P>
The <TT>terminate</TT> operation is used to inform the state management
mechanism that the object is about to be destroyed, and should
be called only in the destructor of the persistent object, and
only after the object has been deactivated using the <TT>deactivate</TT>
operation.
<H3> Lock Management Issues</H3>

<P>
The <I>Arjuna</I> class that manages the concurrency control of
an object is <TT>LockManager</TT>, which provides operations that
allow locks to be set and released on objects. Below are the relevant
parts of the <TT>LockMan.h</TT> header file:
<PRE>
class LockManager : public StateManager
{
public: . . .
	LockResult setlock (Lock *, int retry = 100,
						 unsigned int = 250000);
	<B>LockResult releaselock (const Uid&amp;);

</B>protected:
	LockManager(ObjectType ot = RECOVERABLE, Boolean shared = TRUE);
	LockManager(const Uid&amp; objUid, ObjectType ot = ANDPERSISTENT);
	~LockManager();

	virtual void terminate ();

 private:
	 . . .
};
</PRE>

<P>
The two constructors offer the same functionality as their <TT>StateManager</TT>
counterparts, i.e., creation of new/old persistent objects, and
the ability to specify the use of a persistent (disk based) or
volatile (in-memory based) object store.
<P>
The <TT>setlock</TT> operation must be parameterised with the
type of lock required (<TT>READ</TT> / <TT>WRITE</TT>), and the
number of retries to acquire the lock before giving up (the default
is 100 attempts, each attempt being separated by a 0.25 seconds
delay; the time between retries is specified in <I>micro-seconds</I>.)
<P>
If a lock conflict occurs the current implementation simply times
out lock requests, thereby preventing deadlocks, rather than providing
a full deadlock detection scheme. If the requested lock is obtained,
the <TT>setlock</TT> operation will return the value <TT>GRANTED</TT>,
otherwise the value <TT>REFUSED</TT> is returned. It is the responsibility
of the programmer to ensure that the remainder of the code for
an operation is only executed if a lock request is granted. Below
are examples of the use of the <TT>setlock</TT> operation.
<PRE>
res = setlock(new Lock(WRITE), 10);	// Will attempt to set a
										// write lock 11 times (10
										// retries) on the object
										// before giving up.
res = setlock(new Lock(READ), 0);	    // Will attempt to set a read
										// lock 1 time (no retries) on
										// the object before giving up.
res = setlock(new Lock(WRITE));		// Will attempt to set a write
										// lock 101 times (default of
										// 100 retries) on the object
										// before giving up.
</PRE>

<P>
The concurrency control mechanism has been integrated into the
atomic action mechanism, thus ensuring that as locks are granted
on an object appropriate information is registered with the currently
running atomic action to ensure that the locks are released at
the correct time. This frees the programmer from the burden of
explicitly freeing any acquired locks if they were acquired within
atomic actions. However, if locks are acquired on an object outside
the scope of an atomic action, it is the user's responsibility
to release the locks when required, using the corresponding <TT>releaselock</TT>
operation.
<H4> Miscellaneous <TT>LockManager</TT> Issues</H4>

<P>
If the instances of a class require concurrency control in addition
to state management, then the class should instead be derived
from <TT>LockManager</TT>. Since <TT>LockManager</TT> is derived
from <TT>StateManager</TT>, the operations of <TT>StateManager</TT>
can also be accessed through <TT>LockManager</TT>.
<P>
If an object is making use of the concurrency control mechanism,
many of the operations described in <U><B>Section 2.2.1.4.</B></U>
for manipulating object states (e.g., <TT>activate</TT> and <TT>modified</TT>)
will be called automatically. For example, when a lock is set
on an object, the concurrency control mechanism may call <TT>activate</TT>
on the object, followed by <TT>modified </TT>if the lock was a
write lock.
<P>
The <TT>terminate</TT> operation of <TT>LockManager</TT> should
obviously be used in place of the <TT>StateManager</TT> version
to inform the system that the object is about to be destroyed.
This should be called only in the destructor of the persistent
object. If the object is used within an atomic action then the
system will call <TT>deactivate</TT> automatically, otherwise
<TT>deactivate</TT> must be called by the application programmer.
<H3> Atomic Action Issues</H3>

<P>
Atomic actions can be used by both applications programmers and
class developers. Thus entire operations (or parts of operations)
can be made atomic as required by the semantics of a particular
operation.
<P>
The atomic action mechanism of <I>Arjuna</I> co-ordinates the
state management and concurrency control mechanisms and allows
the operations of objects to begin new atomic actions, end (commit)
the current atomic action, or abort the current atomic action.

<PRE>
class AtomicAction : public StateManager
{
public:
	static AtomicAction* Current();

	AtomicAction ();
	virtual ~AtomicAction ();
	 . . . 
	virtual ActionStatus Begin();
	virtual ActionStatus End();
	virtual ActionStatus Abort();
	 . . . 
	AtomicAction* parent();
	 . . .
};
</PRE>

<P>
The operation that the <TT>AtomicAction</TT> class provides to
begin a new atomic action is called <TT>Begin</TT>. The class
also provides the <TT>End </TT>operation to commit the current
atomic action, and the <TT>Abort </TT>operation to abort the current
atomic action. Each of the operations returns a status, that can
be used to determine whether the operation was successful. An
example of the uses of these operations is given below:
<PRE>
AtomicAction A;			// Create an instance of atomic action
A.Begin();					// Begin the atomic action
. . .
if (OK)
	Result = A.End();		// End (Commit) the atomic action
else
	Result = A.Abort();	// Abort atomic action
</PRE>

<P>
The operations described above are all that are required to make
use of atomic actions, but in addition, the <TT>AtomicAction</TT>
class also provides an operation <TT>Current</TT>, that returns
a pointer to the current atomic action, and an operation <TT>parent
</TT>that returns a pointer to the atomic action's parent. These
are required for handling nested atomic actions.
<H4> Nested Actions</H4>

<P>
There are no special constructs for nesting of actions: if an
action is begun within the scope of another action then it is
automatically nested. This allows for a modular structure to applications,
whereby objects can be implemented using atomic actions within
their methods without the application programmer having to worry
about the applications which use them, i.e., whether or not they
will use atomic actions as well. Thus, in some applications actions
may be top-level, whereas in others they may be nested. Objects
written in this way can then be shared between application programmers,
and <I>Arjuna</I> will guarantee their consistency.
<P>
If a nested action is aborted then all of its work will be undone,
although strict two-phase locking means that any locks it may
have obtained will be retained until the top-level action commits
or aborts. If a nested action commits then the work it has performed
will only be committed by the system if the top-level action commits;
if the top-level action aborts then <I>all</I> of the work will
be undone.
<P>
The committing or aborting of a nested action does not automatically
affect the outcome of the action within which it is nested. This
is application dependant, and allows a programmer to structure
atomic actions to contain faults, undo work, etc.
<P>
<I>Note</I>: <I>Arjuna</I> supports nested top-level atomic actions,
which will be discussed in detail in<U><B> Chapter 6.</B></U>
<H4> Example</H4>

<P>
If we consider the <TT>Array</TT> example given previously, and
assume it is now inherited from the <TT>LockManager</TT> class,
the <TT>set</TT> and <TT>get</TT> operations could be implemented
as shown below:
<PRE>
Boolean Array::set (int index, int value)
{
	Boolean result = FALSE;
	AtomicAction A;

	A.Begin();

	// We need to set a WRITE lock as we want to modify the state.

	if (setlock(new Lock(WRITE), 0) == GRANTED)
	{
		elements[index] = value;
		if (value &gt; 0)
			numberOfElements++;
		if (A.End() == COMMITTED)
			result = TRUE;
	}
	else
		A.Abort();

	return result;
}

Boolean Array::get (int index, int&amp; value)
{
	Boolean result = FALSE;
	AtomicAction A;

	A.Begin();

	// We only need a READ lock as the state is unchanged.

	if (setlock(new Lock(READ), 0) == GRANTED)
	{
		value = elements[index];
		if (A.End() == COMMITTED)
			result = TRUE;
	}
	else
		A.Abort();

	return result;
}
</PRE>

<H2> Deleting Persistent Objects</H2>

<P>
Deleting of persistent objects essentially falls in to two catagories:
deleting passive objects, and deleting active objects.
<H3> Passive Objects</H3>

<P>
If the object state is passive then it resides entirely in the
object store and can be deleted using the appropriate UNIX command.
However, it must be guaranteed that no reference to the object
exists either implicitly (stored within the state of another object),
or explicitly (appearing within the code of an application). If
either of these conditions occurs, if the system attempts to retrieve
the object state from the object store it will fail (for example,
the <TT>setlock</TT> application will return <TT>REFUSED</TT>).
<H3> Active Objects</H3>

<P>
<I>Note</I>: the following issues arise whenever an object goes
out of scope, whether it was created on the heap (in which case
the <TT>delete</TT> operator is being used), or on the stack.
Objects created on the stack require special attention as it is
sometimes more difficult to notice when they are going out of
scope.
<P>
If the object is active then deleting it must be approached with
caution. If the object is not within the scope of an atomic action
then, apart from the issues mentioned in the last section,  deleting
the object is straightforward. However, if the object is within
an atomic action the issues raised become more difficult: if the
action aborts, the states of the objects must be restored, and
this should include &quot;un-deleting&quot; objects which were
deleted - something which could be accomplished for objects created
on the heap if we could redefine the <TT>delete</TT> operator.
Unfortunately, although it is possible to overload the <TT>delete</TT>
operator in C++, this only allows redefinition of the memory allocation/de-allocation
mechanism, and does not allow the actual delete of the object
to be overriden, i.e., postponed until the action either commits
or aborts. Therefore, whenever <TT>delete</TT> is called on an
object the object is destroyed.
<P>
<I>Arjuna</I> has mechanisms to guarantee the consistency of objects
which have been deleted in the scope of an action whether or not
the action commits. However, these mechanisms (<TT>CadaverRecords</TT>)
only guarantee that states are consistent, and cannot manipulate
application pointers. Therefore, if an object is deleted within
an action, application programmers must be carefule about dereferencing
such pointers should the action abort.
<P>
One scheme which is frequently used by <I>Arjuna</I> programmers
in order to overcome this problem is to postpone deleting of objects
until it is certain that actions will commit. This typically takes
the form of building a &quot;pending delete list&quot;: objects
which are to be deleted are placed on to this list, and only when
the action commits do they actually get deleted. If the action
aborts, then the objects can be retrieved from the list.
<H2> Atomic Actions within <TT>save_state</TT> and <TT>restore_state</TT>
</H2>

<P>
When developing persistent objects to be used within atomic actions,
and writing their <TT>save_state</TT> and<TT> restore_state</TT>
methods, it may occur to run atomic actions within these, either
explicitly or implicitly (by calling an object's methods which
use actions). This is not encouraged as this is equivalent to
running an action within the commit (abort) phase of an atomic
action and potentially violates its atomicity properties. Therefore,
consistency cannot be guaranteed.
<H2> Building a Simple Application</H2>

<P>
This section illustrates the points made in previous sections
by outlining a simple application - in this case a simple FIFO
<TT>Queue </TT>class for integer values will be developed. The
implementation of the <TT>Queue</TT> will be with a doubly linked
list structure, and initially it will be implemented as a single
object. We shall be using this example throughout the rest of
this manual to help illustrate the various mechanisms provided
by <I>Arjuna</I>.
<P>
<I>Note</I>: this application code has been written in a style
that is recommended when using <I>Arjuna</I>. For the sake of
simplicity, the entire code for the following application has
not been included in this manual. However, the code for all versions
of this application is available in the <I>Arjuna</I> software
release in the directory <TT>Example/Queue</TT>.
<P>
The queue is a traditional FIFO queue, where elements are added
to the front and removed from the back. The operations provided
by the queue class allow the values to be placed on to the queue
(<TT>push</TT>) and to be removed from it (<TT>pop</TT>), and
it is also possible to change or inspect the values of elements
in the queue. Because a linked list structure is used to maintain
the state of the queue instead of an array, it is not possible
to suffer from queue overflow. However, a limit of <TT>QUEUE_SIZE</TT>
elements has been imposed for this example. The interface definition
of this simple queue class is given below:
<PRE>
const unsigned int QUEUE_SIZE = 40;	// maximum size of the queue

enum QueueStatus { DONE, NOT_DONE, UNDER_FLOW, OVER_FLOW };

// type of list elements
class QueueElement
{
public:
	QueueElement (int);
	~QueueElement ();

	int           value;
	QueueElement* next;
	QueueElement* prev;
};
class Queue
{
public:
	Queue ();
	~Queue ();

	QueueStatus  push (int);
	QueueStatus  pop  (int&amp;);
	unsigned int queueSize ();
	Boolean		  inspectValue (unsigned int, int&amp;);
	Boolean		  setValue (unsigned int, int);

private:
	QueueElement* headOfList;
	QueueElement* tailOfList;
	unsigned int  numberOfElements;
};
</PRE>

<P>
The <TT>push</TT> operation adds a new <TT>QueueElement</TT> to
the head of the list (indicated by <TT>headOfList</TT>). The <TT>pop</TT>
operation removes the first element from the tail of the list.
<TT>queueSize</TT> returns the number of elements in the queue,
<TT>inspectValue</TT> returns the value of the element at the
position in the list indicated by the parameter, and <TT>setValue</TT>
can be used to modify the value of an existing queue element.
<P>
In the following sections, this simple queue class will be modified
to form:
<P>
 A persistent queue class. The state of a queue object will be
stored (explicitly) in an object store after the termination of
the application that created it, and made available to a subsequent
application that uses it.
<P>
 A persistent queue class, whose operations are performed as atomic
actions. Such a queue object is able to remain consistent despite
concurrent usage and host node failures.
<H3> A Persistent Queue Class</H3>

<P>
Below is the interface definition of the persistent queue class:
<PRE>
class Queue : public StateManager
{
public:
	Queue  (const Uid&amp; u, Boolean&amp; res);	// Reincarnation
	Queue  (Boolean&amp; res);					// Creation
	~Queue ();

	QueueStatus  push (int);
	QueueStatus  pop (int&amp;);
	unsigned int queueSize ();
	Boolean		  inspectValue (unsigned int, int&amp;);
	Boolean		  setValue (unsigned int, int&amp;);

	virtual Boolean save_state (ObjectState&amp;, ObjectType);
	virtual Boolean restore_state (ObjectState&amp;, ObjectType);
	virtual const TypeName type () const;

private:
	QueueElement* headOfList;
	QueueElement* tailOfList;
	unaigned int  numberOfElements;
};
</PRE>

<P>
The major differences between the interface for the persistent
queue class and the interface for the simple queue class are:
<P>
(i) the class is derived from the <TT>StateManager</TT> class;
<P>
(ii) the constructors are parameterised with the unique identifier
(<TT>Uid</TT>) of the existing/created persistent queue object;
<P>
(iii) the operations are provided for instances of the queue to
be converted into/from an <TT>ObjectState</TT> object. These modifications,
plus those required to the actual operations of the queue class
will be described in the following sections.
<H4> Constructors and Destructors</H4>

<P>
To access existing persistent objects, and to create new persistent
objects, the queue class must have special constructors. If an
existing persistent object is to be accessed, then the constructor
is required to take the <TT>Uid</TT> of that persistent object
(further issues concerning object naming will be described in<U><B>
Chapter 6 </B></U>when we discuss the name server), and pass it
to the <TT>StateManager</TT> constructor. This informs the state
management mechanism which object state to use for activation,
i.e., which of the states in the object store to load into memory.
Since exception handling is not generally available, the extra
<TT>Boolean</TT> parameter is used to indicate whether the constructor
was successfully executed.
<P>
One implementation of such a constructor is:
<PRE>
Queue::Queue (const Uid&amp; u, Boolean&amp; res) : StateManager(u)
{
	headOfList = 0;
	tailOfList = 0;
	numberOfElements = 0;

	/*
	 * Activate the object causes the persistent object state from
	 * the object store to be loaded into the object.
	 */

	if (!StateManager::activate())
		res = FALSE;
	else
		res = TRUE;
}
</PRE>

<P>
Since a new persistent queue object lacks an old state to activate,
all that is required is an explicit call to <TT>modified</TT>
to ensure that <TT>deactivate</TT> (called in the destructor)
will copy the current state into the object store when the object
is destroyed.
<PRE>
Queue::Queue (Boolean&amp; res) : StateManager(ANDPERSISTENT)
{
	// Initialise Queue instance variables

	headOfList = 0;
	tailOfList = 0;
	numberOfElements = 0;
	res = TRUE;

	// Indicate the object is about to be modified.

	StateManager::modified();			// Indicate modification
}
</PRE>

<P>
The implementation of the destructor for the persistent queue
object is:
<PRE>
Queue::~Queue ()
{
	/*
	 * Deactivate the object; if the object state has been modified,
	 * then the current state is copied to the object store.
	 */

	StateManager::deactivate();
	StateManager::terminate();

	// delete list.
}
</PRE>

<H4> Other Operations</H4>

<P>
Below is the basic structure of the <TT>push</TT> operation for
the persistent queue class (the corresponding <TT>pop</TT> operation
can be similarly implemented):
<PRE>
QueueStatus Queue::push (int value)
{
	QueueStatus   res = NOT_DONE;
	QueueElement* tmp = 0;

	// Indicate the object is about to be modified.

	StateManager::modified();

	if (numberOfElements &lt;= QUEUE_SIZE)
	{
		// Now do modification

		tmp = new QueueElement(value);
		tmp-&gt;next = headOfList;
		if (headOfList)
			headOfList-&gt;prev = tmp;
		else
			tailOfList = tmp;
		headOfList = tmp;
		numberOfElements++;
		res = DONE;
	}
	else
		res = OVER_FLOW;

	return res;
}
</PRE>

<P>
The <TT>setValue</TT> operation could be:
<PRE>
Boolean Queue::setValue (unsigned int index, int&amp; v)
{
	Boolean res       = FALSE;
	QueueElement* tmp = 0;

	StateManager::modified();

	// Traverse list and if element is found, change value to v

	return res;
}
</PRE>

<P>
To allow the state of a queue to be saved to/restored from the
object store, implementations must be provided for the inherited
operations: <TT>save_state</TT>, <TT>restore_state</TT> and <TT>type</TT>.
One possible implementation of these operations is given below
(<I>Note</I>: we deliberately ignore the second parameter in these
examples). The result returned from <TT>save_state</TT> and <TT>restore_state</TT>
indicates if the operations have been completed successfully.
<PRE>
Boolean Queue::save_state (ObjectState&amp; os, ObjectType)
{
	QueueElement* tmp = headOfList;
	Boolean       res = TRUE;

	// First pack away the number of elements.

	res = os.pack(numberOfElements);

	// Now pack each element in the Queue.

	for (int i = 0; (i &lt; numberOfElements) &amp;&amp; (res); i++)
	{
		res = os.pack(tmp-&gt;value);
		tmp = tmp-&gt;next;
	}

	return res;
}
Boolean Queue::restore_state (ObjectState&amp; os, ObjectType)
{
	QueueElement  *tmp = headOfList, *trail = 0;
	Boolean       res  = TRUE;
	int       i, value = 0;

	/*
	 * First delete the old list, if any, as this may not match
	 * the list we are about to restore.
	 */

	for (i = 0; i &lt; numberOfElements; i++)
	{
		tmp = tmp-&gt;next;
		delete headOfList;
		headOfList = tmp;
	}

	// Now unpack the list from the object store.

	numberOfElements = 0;
	headOfList = 0;
	tailOfList = 0;

	res = os.unpack(numberOfElements);
	for (i = 0; (i &lt; numberOfElements) &amp;&amp; (res); i++)
	{
		/*
		 * Unpack each integer value and assemble the queue list.
		 */
	}

	return res;
}
const TypeName Queue::type () const
{
	return &quot;/StateManager/Queue&quot;;
}
</PRE>

<P>
As was indicated in the <TT>Array</TT> example described in <U><B>Section
2.2.1.3.</B></U> it may be possible to save only a subset of the
state of an object if the rest of the state is either unimportant
to the object (e.g., a typical <TT>for-loop</TT> variable), or
can be recalculated from the state which has been saved: the application
programmer decides what constitutes the state of the object. For
the <TT>Queue</TT> example above, this is not possible, but should
be considered whenever writing <TT>save_state</TT> and <TT>restore_state
</TT>operations as this could reduce the size of the persistent
object state with resultant performance benefits.
<P>
As implemented above, concurrent operations on a persistent queue
object could cause inconsistencies in the object state. To overcome
this problem, we now introduce the use of atomic actions.
<H3> Queue Using Atomic Actions</H3>

<P>
To allow the queue class to make use of both the state management
mechanism and the concurrency control mechanism provided by the
<I>Arjuna</I> system, the queue class must now be derived from
the class <TT>LockManager</TT>.
<H4> Constructors and Destructors</H4>

<P>
As stated in the previous section, to use an existing persistent
objects requires the use of a special constructor that is required
to take the <TT>Uid</TT> of the persistent object; the implementation
of such a constructor is given below (note that there is now no
need to activate the object explicitly as this will be done automatically).
<PRE>
Queue::Queue (const Uid&amp; u, Boolean&amp; res) : LockManager(u)
{
	numberOfElements = 0;
	headOfList = 0;
	tailOfList = 0;
	res = TRUE;
}
</PRE>

<P>
The constructor that creates a new persistent object is similarly
modified:
<PRE>
Queue::Queue (Boolean&amp; res) : LockManager(ANDPERSISTENT)
{
	Boolean      res = FALSE;
	AtomicAction A;

	// Initialise queue elements
	numberOfElements = 0;
	headOfList = 0;
	tailOfList = 0;

	if (A.Begin() == RUNNING)	// Try to start atomic action
	{
		if (setlock(new Lock(WRITE), 0) == GRANTED)// Try to set lock
		{
			if (A.End() == COMMITTED)		// Commit
				res = TRUE;
		}
		else 				// Lock refused so abort the atomic action
			A.Abort();
	}
}
</PRE>

<P>
The use of an atomic action within the constructor ensures that
the object's state will be written to the object store when the
top level atomic action commits. Use of atomic actions in operations
is simple: an action must first be declared and its <TT>Begin</TT>
operation invoked, the operation must then set an appropriate
lock on the object (in this case a <TT>WRITE</TT> lock must be
acquired), then the main body of the constructor is executed.
If this is successful the atomic action can be committed, otherwise
it is aborted.
<P>
<I>Note</I>: as shall be shown in <U><B>section 6.4</B></U>, there
are other ways of coding constructors but this method (which will
be used in subsequent examples) is the most modular scheme, i.e.,
it is guaranteed to work correctly in all applications.
<P>
The destructor of the persistent queue class is only required
to call the <TT>terminate</TT> operation of <TT>LockManager </TT>(deactivation
is handled by the atomic action system):
<PRE>
Queue::~Queue()
{
	LockManager::terminate();

	// delete list.
}
</PRE>

<H4> Other Operations</H4>

<P>
If the operations of the queue class are to be coded as atomic
actions, then the <TT>push </TT>operation would be modified to
have the structure given below (the other methods would be similarly
structured):
<PRE>
QueueStatus Queue::push (int&amp; value)
{
	QueueStatus   res = NOT_DONE;
	QueueElement* tmp = 0;
	AtomicAction A;

	if (A.Begin() == RUNNING)
	{
		if (setlock(new Lock(WRITE), 0) == GRANTED)
		{
			if (numberOfElements &lt;= QUEUE_SIZE)
			{
				tmp = new QueueElement(value);
				tmp-&gt;next = headOfList;

				if (headOfList)
					headOfList-&gt;prev = tmp;
				else
					tailOfList = tmp;

				headOfList = tmp;
				numberOfElement++;
				res = DONE;
			}
			else
				res = OVER_FLOW;
		}

		if (res == DONE)
		{
			if (A.End() != COMMITTED)
				res = NOT_DONE;
		}
		else
			A.Abort();
	}

	return res;
}
</PRE>

<P>
The activation and deactivation of a <TT>Queue</TT> object is
performed automatically by the atomic action and concurrency control
mechanisms as described previously.
<P>
Furthermore, because the queue class is now derived from the <TT>LockManager</TT>
class, the operation <TT>type</TT> should be modified to be:
<PRE>
const TypeName Queue::type () const
{
	return &quot;/StateManager/LockManager/Queue&quot;;
}
</PRE>

<H4> Comments</H4>

<P>
Since the queue object is persistent, then the state of the object
will survive any failures of the node on which it is located.
The state of the object that will survive is that produced by
the last top-level committed atomic action performed on the object.
If it is the intention of an application to perform two <TT>push</TT>
operations atomically, for example, then this can be done by nesting
the <TT>push</TT> operations in another enclosing atomic action.
In addition, concurrent operations on such a persistent object
will be serialised, thereby preventing inconsistencies in the
state of the object. However, since the elements of the queue
objects are not individually concurrency controlled, certain combinations
of concurrent operation invocations will be executed serially,
whereas logically they could be executed concurrently. For example,
modifying the states of two different elements in the queue. In
the next section we address some of these issues.
<H3> Queue as a Composite Object</H3>

<P>
If the elements of the queue are themselves derived from <TT>LockManager</TT>,
then they will possess their own concurrency control and persistence
mechanisms from the queue object itself. This allows various application
specific optimisations to be made, for example it would be possible
to add a new element to the queue while inspecting the value of
another element.
<P>
The <TT>QueueElement</TT> class is modified as shown below. Because
these objects are now responsible for setting their own locks
when their states are modified or inspected, it is necessary to
provide new methods for manipulating their states - the once <TT>public</TT>
state now becomes <TT>private</TT>. Such methods could of course
have been added when the queue object was initially implemented,
but we introduce them now to show what the impact of deriving
an existing object from <TT>LockManager</TT> (or <TT>StateManager</TT>)
may be.
<PRE>
class QueueElement : public LockManager
{
public:
	QueueElement (const Uid&amp;, Boolean&amp;)
	QueueElement (int, Boolean&amp;);
	~QueueElement ();

	Boolean getValue (int&amp;);
	Boolean setValue (int);
	Boolean save_state (ObjectState&amp;, ObjectType);
	Boolean restore_state (ObjectState&amp;, ObjectType);
	const TypeName type () const;

	QueueElement* next;
	QueueElement* prev;

private:
	int           value;

};
Boolean QueueElement::getValue (int&amp; v)
{
	Boolean result = FALSE;
	AtomicAction A;

	A.Begin();

	if (setlock(new Lock(READ), 0) == GRANTED)
	{
		v = value;
		if (A.End() == COMMITTED)
			result = TRUE;
	}
	else
		A.Abort();

	return result;
}
</PRE>

<P>
The <TT>save_state</TT> and <TT>restore_state</TT> operations
save the state of the elements, which in this example we shall
consider to be their values only - the queue object maintains
the structure of the elements, i.e., their links:
<PRE>
Boolean QueueElement::save_state (ObjectState&amp; os, ObjectType)
{
	return os.pack(value);
}

Boolean QueueElement::restore_state (ObjectState&amp; os, ObjectType)
{
	return os.unpack(value);
}
</PRE>

<P>
With these changes, it is necessary to modify the <TT>save_state</TT>
and <TT>restore_state</TT> operations for the queue object itself,
as well as those methods which access the element's state variable.
Since it is now the responsibility of each of the queue elements
to save and restore its own state, the queue object need only
save sufficient information to recreate these objects, i.e., it
need only save the <TT>Uid</TT> of each object - the state of
the queue object becomes the identity of each of the elements
rather than their states:
<PRE>
Boolean Queue::save_state (ObjectState&amp; os, ObjectType)
{
	Boolean res       = TRUE;
	QueueElement* tmp = headOfList;

	res = os.pack(numberOfElements);

	for (int i = 0; (i &lt; numberOfElements) &amp;&amp; (res); i++)
	{
		// the QueueElement object saves its own state
		res = (tmp-&gt;get_uid()).pack(os);
		tmp = tmp-&gt;next;
	}

	return res;
}
Boolean Queue::restore_state (ObjectState&amp; os, ObjectType)
{
	Boolean res       = TRUE;
	QueueElement* tmp = headOfList;

	// delete old list and initialise state variables
	res = os.unpack(numberOfElements);

	for (int i = 0; (i &lt; numberOfElements) &amp;&amp; (res); i++)
	{
		Uid u;

		res = u.unpack(os);
		if (res)
		{
			res = FALSE;

			// the QueueElement object restores its own state

			tmp = new QueueElement(u, res);

			// add to list if res == TRUE
		}
	}

	return res;
}
</PRE>

<P>
The queue operations can now be modified to take this additional
functionality in to account, possibly allowing interleaving of
certain operations. For example, it is now possible to interleave
the <TT>inspectValue</TT> and <TT>getValue</TT> operations of
the <TT>Queue</TT> class, as these do no change the state of the
queue. If these operations are performed by different clients
concurrently and act on the same queue element then they will
be serialised. The <TT>push</TT> and <TT>pop</TT> methods modify
the state of the queue and would typically be implemented as exclusive
operations, i.e., the code remains the same as before.
<H1> Constructing Distributed Applications</H1>

<P>
Writing distributed applications can be substantially more complex
than writing purely local applications as the programmer has to
worry about client-server interactions. <I>Arjuna</I> uses a stub
generation tool to automatically generate much of the code required
for clients and servers thereby providing distribution transparency.
<H2> The Stub Generator</H2>

<P>
The stub generator processes C++ class definitions and produces
stub code that allows instances of those classes to be accessed
remotely. That is, the public operations of the objects can be
invoked from nodes other than the node on which the objects are
resident. This is achieved by the stub generator producing several
new classes, the most important of which are a client stub class,
and a server stub class. These classes interface to the low-level
RPC mechanism so that object invocations and replies can be transmitted
across the network.
<P>
When client code invokes an operation on a remote object, the
operation is actually invoked on the client stub object. This
stub object packs up the parameters to the operation with sufficient
information for the correct operation to be invoked at the server
side and transmits the request via RPC to the remote server stub
object. The server stub object unpacks the data received and invokes
the specified object operation. When the operation has completed
the stub objects are responsible for packing and transmitting
the reply to the client program.
<P>
Figure 3.1 illustrates the client stub object (CSO), server stub
object (SSO), and object (O, depicted as shaded).
<P>
<B>Figure 3.1: Client and Server stubs</B>
<P>
The diagram in figure 3.2 shows the difference in software structure
between user code accessing a local service and a user accessing
a remote service. The service, in this context, is the set of
operations provided by the object.
<P>
<B>Figure 3.2: Software Structure for Local and Remote Services</B>
<H3> Basic Use of the Stub Generator</H3>

<P>
As has already been stated, the stub generator (invoked here by
the command  <TT>tatsu</TT>) uses the information from a standard
C++ header file to generate: replacement header files, client
stub code, server stub code, and any required parameter marshalling
code. This is illustrated in figure 3.3, with a header file (called
<TT>Example.h</TT>) that contains a class called <TT>Stack</TT>.
<P>
<B>Figure 3.3: Stub Generator</B>
<P>
The C++ header file (<TT>Example.h </TT>in this example) contains
the interface definition for the classes whose operations may
be invoked remotely. First, let us describe the way this class
might be defined and used in a non-distributed application. An
example of an interface definition, stored in a file called <TT>Example.h</TT>,
is given below.
<PRE>
#include &lt;Common/Boolean.h&gt;

class Stack
{
public:
	Stack();						// constructor
	~Stack();						// destructor

	Boolean Push(long val);
	Boolean Pop(long&amp; val);

private:
	int top;
	long values[100];
};
</PRE>

<P>
Let the implementation of the class <TT>Stack</TT> be in the file
called <TT>Example.cc</TT>, and of the form:
<PRE>
#include &quot;Example.h&quot;

Stack::Stack(){ . . . }
Stack::~Stack() { . . . }
Boolean Stack::Pop(long val) { . . . }
Boolean Stack::Push(long&amp; val) { . . . }
</PRE>

<P>
And, let the user application code be in a file called <TT>UserAppl.cc</TT>,
and of the form:
<PRE>
#include &quot;Example.h&quot;

int main(int argc, char* argv[])
{
	int v;
	Boolean err;
	Stack StackObj;
	err = StackObj.push(10);
	. . .
	err = StackObj.pop(v);
}
</PRE>

<P>
To compile the above simple application, the following commands
would be required:
<PRE>
CC -c UserAppl.cc						--	Compile user application 
CC -c Example.cc						--	Compile stack 
CC -o UserAppl UserAppl.o Example.o	--	Link application and stack
											to form executable program
</PRE>

<P>
To allow the above user application to create, and invoke operations
on remote stack objects, the following must be done: The file
<TT>Example.h</TT> must be passed through the stub generator;
this would produce the files: <TT>Example_stub.h</TT>, <TT>Stack_stubclass.h</TT>,
<TT>Stack_client.cc</TT>, <TT>Stack_server.cc</TT>, <TT>Stack_servermain.cc</TT>
and possibly <TT>Stack_marshall.cc</TT>. The header file <TT>Example_stub.h</TT>
should be used  by the user application and the implementor of
the stack object instead of <TT>Example.h</TT>, because <TT>Example_stub.h</TT>
contains the class interfaces for server stub objects, client
stub objects, and the actual remote objects. To ensure that the
correct class interface is used, the correct preprocessor variables
must be set, before including <TT>Example_stub.h</TT>.
<P>
For example, the implementor of user application above would replace:
<PRE>
#include &quot;Example.h&quot;
</PRE>

<P>
with:
<PRE>
#include &quot;Example_stub.h&quot;
</PRE>

<P>
And, the implementor of stack object would replace:
<PRE>
#include &quot;Example.h&quot;
</PRE>

<P>
with:
<PRE>
#define STACK_SERVER
#include &quot;Example_stub.h&quot;
</PRE>

<P>
If a stack server program is to be created, then the code in <TT>Stack_servermain.cc</TT>
should be compiled, and linked into the server.
<P>
To compile the above files, to form the user application and a
stack server program, the following commands would be required:
<P>
-- Run stub generator
<PRE>
tatsu Example.h +s stackserver
</PRE>

<P>
The +s option is used to indicate the name of the stack server
program, that will be produced by the following commands.
<P>
-- Server Program
<PRE>
CC -c Example.cc				-- Compile stack
CC -c Stack_server.cc			-- Compile server stub code
CC -c Stack_servermain.cc		-- Compile server main body
</PRE>

<P>
<B>--</B> Link stack and server stack stub to form the server
program
<PRE>
CC -o stackserver Example.o Stack_server.o Stack_servermain.o
</PRE>

<P>
To install the application, the resulting program, <TT>stackserver</TT>,
should be copied to the server installation directory, specified
at system configuration time (as described in Appendix A).
<P>
-- User application Program
<PRE>
CC -c UserAppl.cc							--	Compile user application
CC -c Stack_client.cc						--	Compile client stub code
CC -o UserAppl UserAppl.o Stack_client.o	--	Link user application
												with client stub to form
												the application program
</PRE>

<H3> Distributing the Queue</H3>

<P>
We shall now use the application introduced in the previous chapter
and extend the queue so that it can be used in a distributed manner.
The two examples we shall cover are:
<P>
 A persistent queue class, whose operations are performed as atomic
actions, and are remotely invocable. Such a queue object should
be able to remain consistent despite the failures of both the
node on which it is located and the node on which its user is
located. The queue object should also remain consistent despite
concurrent operations (potentially remote in origin) being performed
upon it.
<P>
 A distributed queue class, where both the queue object and the
element objects will be persistent objects, whose operations are
provided as atomic actions, and are remotely invocable. Such a
queue object should be able to survive the failures of the node
on which it is located, and operations that do not involve elements
that are on failed/inaccessible nodes should be successful. The
queue object and element objects should also remain consistent
despite concurrent operations being performed upon them.
<P>
Because of the current lack of exception handling in most C++
implementations, it is not possible for the stub generated code
to raise an exception if an error occurs during a remote operation,
e.g., the remote object has failed. As such, it is necessary for
application programmers to write code in a manner which allows
them to determine whether or not a remote call has been successful.
It is important to determine this <I>before</I> attempting to
use the results of such a call: if the call fails then the results
will be meaningless, and possibly illegal if not initialised before
transmission.
<P>
The general way of writing such applications is to include a dummy
parameter in all remote class methods (including constructors).
This parameter is set to a certain value before making the call
and the remote object will change it if it receives the request.
The caller then inspects this parameter when the procedure call
returns, and only uses the results if it has been changed successfully.
For more on this topic see <U><B>Chapter 7</B></U>.
<H2> A Remotely Invocable Queue</H2>

<P>
In this section, the implementation of a queue class whose operations
can be invoked remotely will be described; this class will be
implemented with the help of the stub generator provided by the
<I>Arjuna</I> system. The structure of the resulting system is
illustrated in figure 3.4, the persistent object state being accessed
by server processes created by the application (Client), the server
process performing operations on the persistent object state using
atomic actions.
<P>
<B>Figure 3.4: Distributed Queue</B>
<P>
If the operations of the queue objects are to be invoked remotely,
the class interface definition will have to be processed by the
stub generator to produce the appropriate stub code.
<P>
In this example, because the elements of the queue are not remotely
invocable, the class definition for <TT>QueueElement</TT> should
not be processed by the stub generator. We shall now assume that
the <TT>QueueElement</TT> interface and implementation are in
separate files from the <TT>Queue</TT> class (<TT>QueueElement.h</TT>
and <TT>QueueElement.cc</TT> respectively). To prevent the stub
generator attempting to create stub code for <TT>QueueElement</TT>
the following pre-processor directive should be placed immediately
before the <TT>QueueElement</TT> interface definition (for more
details see the<U><B> chapter 4</B></U>):
<PRE>
// @NoRemote, @NoMarshall
class QueueElement : public LockManager
{
	....
};
</PRE>

<P>
In addition, if the <TT>QueueElement.h</TT> is included in the
file <TT>Queue.h</TT> then the following directive must be added
to prevent the stub generator from expecting to find stub generated
header files:
<PRE>
#ifdef STUB
#  pragma @NoRename
#endif
</PRE>

<P>
From the class definition in the file <TT>Queue.h</TT> the stub
generator will produce five files <TT>Queue_stub.h</TT>, <TT>Queue_stubclass.h</TT>
<TT>Queue_client.cc</TT>, <TT>Queue_server.cc</TT> and <TT>Queue_servermain.cc</TT>.
The file <TT>Queue_stub.h</TT> contains the class definitions
for the client stub objects, server stub objects, and the remote
objects. This header file should be included by both the users
of the remote objects, and the implementation of the remote object.
The following must be placed in the queue class implementation
before the <TT>Queue_stub.h</TT> is included, to ensure that the
correct remote object definitions are used.
<PRE>
#define STATEMANAGER_SERVER
#define LOCKMANAGER_SERVER
#define QUEUE_SERVER
</PRE>

<P>
The <TT>Queue_client.cc</TT> code should be compiled, and the
resulting object code be linked with the queue client code. The
<TT>Queue_server.cc</TT> and <TT>Queue_servermain.cc</TT> code
should also be compiled, and the resulting object code linked
with the implementation code for the queue. It should be noted
that no changes to the client code or the class implementation
code are required.
<H3> Comments</H3>

<P>
Distribution of the queue does present reliability problems in
that the node on which the queue object (server) is located and
the node on which the user (client) is located may fail independently,
or a failure in the network could cause the failure of an invocation.
The use of atomic actions to perform operations on the queue will,
however, ensure the consistency of the queue object. If the node
on which the user (client) is located fails, then the server for
the queue object will become an orphan; this will be detected
by the orphan detection and killing sub-system of the RPC system,
which will abort the server.
<H2> An Internally Distributed Queue</H2>

<P>
The queue objects outlined in the previous section have their
entire state in one place; in this section a queue whose elements
are individually distributed (on many nodes) will be examined.
The resulting structure of such a queue is illustrated in figure
3.5, where an application process, <I>C</I>, is using the queue
object managed by the server process, <I>S</I>. The elements of
the queue are distributed amongst the nodes <I>X</I>, <I>Y</I>
and <I>Z</I>. The processes that contain elements are labelled
<I>E</I> (as before, boxes drawn by doted lines represent the
lock store, and the boxes drawn by solid lines represent the persistent
object store).
<P>
<B>Figure 3.5: Internal Distributed Queue System</B>
<P>
To allow the queue objects to contain elements that are distributed
on other nodes, it is necessary to pass the <TT>QueueElement</TT>
class through the stub generator. The pre-processor directive
applied in<U><B> section 3.2. </B></U>should now be removed. In
this example we wish to maintain the list structure at the <TT>Queue</TT>
object, but have the states of the <TT>QueueElement</TT> objects
remote from it. To do this we modify <TT>QueueElement</TT> slightly,
removing the pointers to other <TT>QueueElement</TT> objects.
We introduce a new class <TT>QueueLinks</TT> to maintain the list
structure, which the <TT>Queue</TT> now uses to gain access to
the element data:
<PRE>
// @NoRemote, @NoMarshall
class QueueLinks
{
public:
	QueueLinks ();
	~QueueLinks ();

	QueueElement* data;	// the actual data, which is remote
	QueueLinks*   next;	// pointers to other remote objects
	QueueLinks*   prev;
};
</PRE>

<P>
The following must be placed in the <TT>Queue</TT> class implementation
before the <TT>QueueElement_stub.h</TT> is included, to ensure
that the remote object definitions for the <TT>QueueElement </TT>are
used.
<PRE>
#define STATEMANAGER_SERVER
#define LOCKMANAGER_SERVER
#define QUEUEELEMENT_SERVER
</PRE>

<H3> Comments</H3>

<P>
Introduction of internal distribution into the queue object means
that operations that require elements on a node that are inaccessible
will not be performed successfully, although other operations
will be successful.
<P>
Another problem that could arise from this implementation is that
element objects could be accessed directly by a user application.
This would not cause the element object's state to become inconsistent,
because its operations are performed within atomic actions. However,
it could cause the state of the queue object to become inconsistent.
<P>
So far we have considered having either all list elements local
to the queue, or all of them remote from the queue. If it is required
to combine both local and remote instances of the <TT>QueueElement</TT>
object within the queue, then the interested reader is referred
to the following chapter.
<H1> Stub Generation Specifics</H1>

<P>
mention new directives (turn warnings of class stub incompatabilities
off, ...)
<H2> Introduction</H2>

<P>
The aim of the stub generator is to take a standard C++ header
file defining some class and produce from it a set of equivalent
files containing replacement stub-class definitions together with
the code that implements the client and server operations of the
stub classes. Unfortunately this seemingly simple requirement
is impossible to meet in practice; thus the stub generator imposes
certain restrictions on the structure and contents of any header
files it processes, as described in the following sections.
<H2> Assumptions</H2>

<P>
The stub generator assumes that its input file contains syntactically
valid C++ and although it performs some checking it is not intended
to replace the compiler and can become confused when presented
with invalid input.
<H2> Files, Directives and Options</H2>

<P>
The stub generator normally generates a <I>set</I> of files for
<I>each</I> class it detects in the input file. However, this
behaviour can be modified by inclusion of stub generation specific
directives in the input file.
<H3> Output Files</H3>

<P>
For a given input file <I>Foo.h</I> that contains a class called
<I>Fudge</I>, the stub generator will, by default, produce the
following files:
<P>
 <B>Foo_stub.h.</B> Replacement header file - should be included
in source code in place of <I>Foo.h.</I> The contents of this
file are similar to the original input file except that class
definitions will have been removed into separate header files
that will be automatically included. Certain other constructs
may also be removed - in particular, inline function definitions.
Inline definitions and/or extern declarations for marshalling
operations may also have been inserted.
<P>
 <B>Fudge_stubclass.h.</B> This file contains the definitions
for the new classes that replace the original class <I>Fudge</I>.
These classes are named <I>LocalFudge</I>, <I>RemoteFudge</I>,
and <I>ServerFudge</I>. C preprocessor directives attempt to hide
this name change from the user.
<P>
 <B>Fudge_client.cc.</B> Client side code that provides new implementations
of all public operations of the original class as RPC calls to
the server.
<P>
 <B>Fudge_server.cc.</B> Server side code that decodes incoming
RPC requests, calls the original class operations, and returns
the results to the caller.
<P>
 <B>Fudge_servermain.cc.</B> Simple main program that creates
an instance of the server class and causes it to wait for incoming
requests.
<P>
 <B>Fudge_marshall.cc.</B> Automatic marshalling/unmarshalling
code for instances of the class <I>Fudge</I>. Marshalling code
for pointers and references may also be present in this file.
<H3> Directives</H3>

<P>
To ensure that the header file used as input is still acceptable
to standard C++ compilers, stub generation directives are hidden
within comments. Syntactically they are classed are declaration
specifiers by the grammar (that is, like <I>static</I> or <I>const</I>,
etc.) and thus should precede the class declaration to which they
apply. More than one directive may be given at a time, though
some conflict with each other. The current set is:
<P>
 <B>@Remote.</B> Indicates that the following class will be accessed
remotely so the stub generator should attempt to produce client
and server code and definitions to accomplish this.
<P>
 <B>@NoRemote.</B> The negation to the above. In this case no
RPC code will be generated for this class. However its public
interface may still be augmented with the addition of marshalling
code depending upon the setting of the following options.
<P>
 <B>@AutoMarshall.</B> Attempt to generate marshalling code for
this class automatically. This enables instances of the class
to be passed as arguments in RPC calls.
<P>
 <B>@UserMarshall.</B> Augment the interface with marshalling
operation signatures but do not generate the code automatically
- this must be provided by the user.
<P>
 <B>@NoMarshall.</B> No marshalling is allowed on instances of
this class.
<P>
 <B>@NoClient.</B> Applicable only within a class declaration
and only to member functions. Indicates that the following operation
should not be provided in the client interface regardless of its
visibility.
<P>
The following directives are only applicable in the declaration
of a parameter list for a member function. They modify the default
parameter passing behaviour appropriately
<P>
 <B>@In.</B> Mark parameter as input only. This is the default
for all parameters except pointers, references and arrays unless
they are marked const.
<P>
 <B>@Out.</B> Mark parameter as output only. Never a default,
but useful in those cases where the parameter is set by the called
operation but invalid before the call (so an attempt to transmit
it in the call could fail).
<P>
 <B>@InOut.</B> The default for pointers, references and arrays
 Causes such parameters to be passed by value result (copy-in,
copy-out) as an approximation to call be reference.
<P>
The default options for a class are <B>@Remote, @NoMarshall.</B>
Note that due to limitations in the current implementation classes
that can be accessed remotely cannot be marshalled and passed
as parameters.
<H3> Command Line Options</H3>

<P>
The stub generator supports a small set of command line arguments.
All command line arguments that start with a minus sign (for example
-I, -D etc.) are passed directly to the preprocessor unaltered,
while those that start with a plus sign (+) affect the execution
of the stub generation process in some way. The current set of
options is:
<P>
 <B>+S.</B> Indicates that the preprocessed output should be saved
in a file suffixed by '.i'. This file can later be used as input
to the stub generator directly.
<P>
 <B>+w.</B> Enable the printing of warning messages. By default
only error messages are printed.
<P>
 <B>+bc.</B> Enable 2.0 compatibility mode. This option forces
any nested types to be exported to global scope to conform with
the old C++ language semantics. 
<P>
 <B>+s servername.</B> Change the name of the server for a given
interface to <I>servername</I>. This name is used by the underlying
RPC mechanism to start a server process on the home node of the
object.
<P>
 <B>+[dfv]level.</B> Stub generation debugging. Only really of
use to the maintainers of the stub generation system. Included
here for completeness only.
<P>
 <B>+y.</B> Enable yacc level debugging. Sets the variable <TT>yydebug</TT>
to 1 to force the yacc parser to print its debugging information.
<H2> Processing Caveats</H2>

<P>
Initially, the input file must be preprocessed before parsing
commences to remove all C++ preprocessor directives. By default
this preprocessing is done by invoking the compiler used to compile
<I>Arjuna</I> (as specified at configuration time) and passing
it the <I>-E</I> (preprocess only flag). However, some compiler
driver programs produce no output when given header files (.h
files) as input (Cfront 2.1 based systems typically suffer from
this). The stub generator attempts to detect this and compensate
by running <I>/lib/cpp </I> on the input file in this case. While
this should produce compilable output it may not necessarily be
correct if the driver program normally invoked the C preprocessor
with extra arguments (typically -D and -U flags).
<P>
This preprocessing can also cause problems if, for example, array
sizes were defined using preprocessor <I>#define</I> directives
rather than C++ language facilities since the generated output
file would no longer contain such directives.
<H2> Parameter Marshalling</H2>

<P>
The stub generator attempts wherever possible to use the same
statement syntax for (un)marshalling parameters of all types.
To this end its uses overloaded &lt;&lt; (marshall) and &gt;&gt;
(unmarshall) operations applied to the RPC buffers. The standard
RPC buffer class contains operations to (un)marshall all the standard
C++ types and the stub generator will create new (un)marshalling
operations for structured types whenever possible. Thus a statement
of the form:
<P>
<TT>rpcBuffer1 &lt;&lt; var1</TT>
<P>
marshalls the variable <TT>var1</TT> into the RPC buffer <TT>rpcBuffer1</TT>.

<H3> Marshalling Classes</H3>

<P>
To support the above style of parameter marshalling the stub generator
generates several new operations for any class that is marked
<I>@AutoMarshall. </I>Firstly, it generates several new definitions
for the operations &gt;&gt; and &lt;&lt; that allow the marshalling
of instances of the class, pointers to and references to instances
of the class. Secondly, it augments the class definition with
two new public operations that are responsible for doing the actual
marshalling by marshalling the individual components of the class
one at a time. These operations have the following signature:
<P>
<TT>virtual void marshall (RpcBuffer&amp;);<BR>
virtual void unmarshall (RpcBuffer&amp;);</TT>
<H3> Marshalling Pointers and References</H3>

<P>
The stub generator attempts to preserve the integrity of any arbitrary
data structure that needs to be passed as a parameter. To this
end it maintains a table of pointers to passed objects on a per
call basis so that if the same pointer is passed more than once
in a parameter list then whatever is being pointed at is <I>packed
only once </I>into the RPC buffer. Code in the server rebuilds
the same data structure including duplicating pointers etc.
<P>
To ensure that C++ reference semantics are obeyed the stub generator
implicitly converts references into pointers at the client and
marshalls the resulting pointer. Server code ensures that the
user is still passed a reference as it expects. Note that this
implicit conversion only occurs if the reference is to a fundamental
type (<TT>int</TT>, <TT>char</TT>, class instance, etc.). Other
references (for example, reference to pointer) are passed unmodified.

<H2> Limitations</H2>

<P>
Remote procedure call imposes a restricted set of capabilities
over traditional calls. Thus the stub generator imposes the following
restrictions upon the form of the class and the operations its
supports:
<P>
 <B>No public variables and friends.</B> The existence of public
variables in a class definition breaks the fundamental encapsulation
property assumed by the stub generator, so any such variables
are removed automatically (with warnings) as the class definition
is processed.
<P>
 <B>No variable length argument lists.</B> These are disallowed
since the stub code needs to know exactly the type and number
of arguments to each operation for marshalling purposes. 
<P>
 <B>No inline operation definitions.</B> These are currently discarded
as they make no sense to the stub generated version of the class
at the client. Future versions of the stub generator will ensure
that such inlines are made available in the server.
<P>
 <B>No static members.</B> Classes cannot contain static members
since the stub generator cannot enforce the semantics of such
variables correctly.
<P>
 <B>No pointers to functions.</B> Allowing pointers to functions
requires the ability for the server to call back to the client
to execute the required code. The current RPC implementation does
not provide the required functionality.
<P>
 <B>No operator overloading.</B> This is caused by the fact that
such operations typically take instances of the same class as
arguments and would thus require object mobility (the instances
could be on different remote nodes).
<P>
 <B>Parameter Semantics.</B> Pointer and reference arguments are
currently implemented as value / result. This approach has several
potential problems that arise due to a variety of causes. Firstly,
typical C++ header files contain not only class definitions but
also inline function definitions, macros, manifest constants,
various preprocessor directives etc. Secondly, type information
about parameters, etc. may be incomplete. For example, declaring
a variable to be a pointer to some type does not imply that the
variable points to a single instance of that type - it might actually
point to an array. This is especially true if the type is char
* - that is, a pointer to character that by convention is used
to represent a string, or a list. Therefore, the stub generator
imposes certain semantics upon pointers such that a pointer to
a type is always considered to point to only one instance of that
type - except for the character pointers that retain their traditional
meaning. 
<H2> Example</H2>

<P>
The following figures show an example of the typical output files
that are produced using the default settings, although in the
interests of saving paper the code files have been pruned of some
of the actual code generated.
<P>
<B>Input File: Simple.h</B>
<PRE>
class Simple
{
public:
	Simple (long = 3);
	~Simple ();

	void getSimple (long&amp;);

private:
	long m;
};
</PRE>

<P>
<B>Output File: Simple_stub.h</B>
<PRE>
/*
 * Automatically Generated by:
 * Arjuna Stub Generator Version 2.1 beta
 *
 * Do Not Edit By Hand
 *
 */

#ifndef SIMPLE_H_
#define SIMPLE_H_

#include &lt;StubGen/Abort.h&gt;
#include &lt;StubGen/RpcBuffer.h&gt;
#include &lt;StubGen/ClientRpc.h&gt;
#include &lt;StubGen/ServerRpc.h&gt;
#include &lt;StubGen/RpcControl.h&gt;

#include &quot;Simple_stubclass.h&quot;

#endif  /* SIMPLE_H_ */
</PRE>

<P>
<B>Output File: Simple_stubclass.h</B>
<PRE>
/*
 * Automatically Generated by:
 * Arjuna Stub Generator Version 21 beta
 *
 * Do Not Edit By Hand
 *
 */


#ifndef SIMPLE_SERVER
#undef Simple
#define Simple RemoteSimple
#endif

class RemoteSimple 
{
public:
	RemoteSimple (long = 3, RpcControl *crpc = 0);
	~RemoteSimple ();
	void getSimple (long &amp; );
protected:
	RemoteSimple(RpcControl *, const RpcBuffer&amp;, char);
private:
	virtual RpcControl *_get_handle () const;

	RpcControl *_client_handle;
	char _do_delete;
	RpcBuffer _myhash_val;
};


#ifdef SIMPLE_SERVER
#undef Simple
#define Simple LocalSimple
#endif

class LocalSimple;

class ServerSimple 
{

public:
	ServerSimple ();
	~ServerSimple ();

	void Server (int, char **);
	long DispatchToClass (LocalSimple*,long, RpcBuffer&amp;, RpcBuffer&amp;);

private:
	long DispatchToOper (LocalSimple *,long, RpcBuffer&amp;, RpcBuffer&amp;);

	long Simple200112908(LocalSimple *, RpcBuffer&amp;, RpcBuffer&amp;);
	long Simple201161494(LocalSimple *, RpcBuffer&amp;, RpcBuffer&amp;);
	long getSimple40141718(LocalSimple *, RpcBuffer&amp;, RpcBuffer&amp;);

	LocalSimple *therealobject;

};
class LocalSimple 
{
public:
	LocalSimple (long = 3);
	~LocalSimple ();
	void getSimple (long &amp; );

private:
	long m;
};

</PRE>

<P>
<B>Output File: Simple_client.cc</B>
<PRE>
/*
 * Automatically Generated by:
 * Arjuna Stub Generator Version 2.1 beta
 *
 * Do Not Edit By Hand
 *
 */


#include &quot;Simple_stub.h&quot;

. . .

void RemoteSimple::getSimple (long &amp; _Par_0_)
{
	RpcBuffer cbuffer(_myhash_val);
	RpcBuffer rbuffer;
	RPC_Status rpc_status = OPER_UNKNOWN;
	long server_status = 0;

	cbuffer &lt;&lt; &amp;_Par_0_;	// note conversion of reference to pointer

	rpc_status = _client_handle-&gt;Call(40141718, cbuffer, 
										server_status, rbuffer);

	if (rpc_status == OPER_DONE &amp;&amp; server_status == 0)
	{
		long * _Par_0_Ptr = &amp;_Par_0_;	// reconvert back
		rbuffer &gt;&gt; _Par_0_Ptr;
	}
	else
		rpc_abort();
}

</PRE>

<P>
<B>Output File: Simple_server.cc</B>
<PRE>
/*
 * Automatically Generated by:
 * Arjuna Stub Generator Version 2.1 beta
 *
 * Do Not Edit By Hand
 *
 */

#define SIMPLE_SERVER
#include &quot;Simple_stub.h&quot;

. . . 
void ServerSimple::Server ( int argc, char **argv )
{
	ServerRpc ServerRPC;
	long opcode, errcode;

	ServerRPC.Initialise(argc, argv);

	for (;;)
	{
		RpcBuffer work;
		RpcBuffer result;

		ServerRPC.GetWork(opcode, work);
		errcode = DispatchToClass(therealobject, 
									opcode, work, result);
		ServerRPC.SendResult(errcode, result);
	}
}

long 
ServerSimple::getSimple40141718 (Simple *theobject, 
									RpcBuffer&amp; work, RpcBuffer&amp; result)
{
	long *_Par_0_;	// ref came across as ptr
	work &gt;&gt; _Par_0_;

	theobject-&gt;getSimple(*_Par_0_);
	result &lt;&lt; _Par_0_;
	
	// clean up any allocated memory
	long dummy = 0;
	work.clearMap();
	if (work.addPtr(_Par_0, dummy)
		delete _Par_0_;

	return OPER_DONE;
}
</PRE>

<P>
<B>Output File: Simple_servermain.cc</B>
<PRE>
/*
 * Automatically Generated by:
 * Arjuna Stub Generator Version 2.1 beta
 *
 * Do Not Edit By Hand
 *
 */

#include &quot;Simple_stub.h&quot;
int main ( int argc, char **argv )
{
	ServerSimple Simpleserver;

	Simpleserver.Server(argc, argv);
	return 0;
}
</PRE>

<H2> Local and Remote Instances</H2>

<P>
&lt;Graham, need to put something here about how to combine both
local and remote instances in a given object/application. Basically
create instances of LocalX and RemoteX directly.&gt;
<H1> Advanced Programming Techniques</H1>

<H2> Nested Top-Level Atomic Actions</H2>

<P>
From release 2.0, <I>Arjuna</I> supports nested (independent)
top-level actions, which can be used to relax strict serialisability
in a controlled manner. A nested top-level action can be executed
from anywhere within another atomic action and has the property
that its outcome is not controlled by the enclosing (nesting)
action, i.e., if it commits then this cannot be undone even if
the action within which it was nested aborts.
<P>
<B>Figure 5.1: Nested Top-Level Action</B>
<P>
Figure 5.1 shows a typical nesting of atomic actions, where action
B is nested within action A. Atomic action C, however, although
nested within action B is an independent top-level action, and
commits/aborts independently of the other actions within the structure.
Because of the nature of nested top-level actions, they produce
non-serlisable affects which cannot be undone by aborting the
action they were nested within.
<P>
Top-level actions can be used within an application by declaring
and using instances of the <TT>TopLevelAction</TT> class (they
are used in exactly the same way as other atomic actions):
<PRE>
class TopLevelAction : AtomicAction
{
public:
	TopLevelAction ();
	~TopLevelAction ();

private:
	....
};
</PRE>

<H2> Naming Remote Persistent Objects </H2>

<P>
In the previous examples persistent objects were named by explicitly
stating the object's unique identifier. <I>Arjuna</I> also provides
an abstract naming scheme for <I>persistent</I> objects. This
naming scheme is based around the use of instances of the class
<TT>ArjunaName</TT>.
<P>
The <TT>ArjunaName</TT> class provides an interface to a (possibly
replicated) name server, allowing the names of persistent objects
to be registered and searched for. Using this scheme individual
persistent objects (whether local or remote) can be named by strings.
<H3> Class Interface Modifications</H3>

<P>
To enable the use of an <TT>ArjunaName</TT>, a persistent object's
interface needs to be changed to provide two additional constructors.
The first constructor (with <TT>char*</TT> parameter) is for creating
a new persistent object, the name of the new persistent object
being the value of the parameter. The second constructor (with
<TT>ArjunaName</TT> parameter) is for accessing existing (already
created and registered with the name server) persistent objects.
For example (extending the <TT>Queue</TT> example of <U><B>chapters
2 and 3</B></U>):
<PRE>
#include &lt;ArjServers/ArjName.h&gt;
#include &lt;Arjuna/LockMan.h&gt;
. . .

class Queue : public LockManager
{
public:
  Queue (char* name);
  Queue (ArjunaName AN);
  . . .
private:
  . . .
};
</PRE>

<P>
In the following sections we will describe how a client could
use these operations, and then how they should be implemented
in the server.
<H3> Creating a New Named Object (Locally)</H3>

<P>
If a client wishes to create a new persistent spreadsheet named
&quot;<TT>EspritCosts</TT>&quot; on the client node, the following
code is required (where <TT>ResearchFund</TT> is the name used
by the program).
<PRE>
char *name = &quot;EspritCosts&quot;;
. . .
SpreadSheet ResearchFund(name);
</PRE>

<H3> Creating a New Named Object (Remotely)</H3>

<P>
If a client on one machine (called &quot;<TT>semillon</TT>&quot;)
wishes to create a new persistent object (named &quot;<TT>EspritCosts</TT>&quot;)
on a specific node (called &quot;<TT>ulgham</TT>&quot;), the following
code is required (besides the server code being installed on the
remote machine). (<I>Note</I>: in a future release of the <I>Arjuna</I>
system, the stub generator will be enhanced to hide the details
of the RPC related code that needs to be provided by the programmer;
this will clean up the slightly untidy scheme currently in use).
<PRE>
char *name			= &quot;EspritCosts&quot;;
char *hostname		= &quot;ulgham&quot;;
char *servicename	= &quot;SpreadSheetServer&quot;;
. . .
//some Rpc related code
ClientRpc  *RPCClient = new ClientRpc;
RPCClient-&gt;SetHost(hostname);
RPCClient-&gt;SetServiceName(servicename);
RpcControl *RPCCtl  = new RpcControl(RPCClient);
SpreadSheet ResearchFund(name, RPCCtl);
</PRE>

<H3> Using An Existing Named Object</H3>

<P>
If a client wishes to use an existing persistent spreadsheet,
the following code is required.
<PRE>
char *name = &quot;EspritCosts&quot;;
. . .
ArjunaName AN(name);
ClientRpc  *RPCClient = new ClientRpc(&amp;AN);
RpcControl *RPCCtl  = new RpcControl(RPCClient);
SpreadSheet ResearchFund(AN, RPCCtl);
</PRE>

<H3> Implementation of the Naming Constructors</H3>

<P>
The constructor that is used for creating new persistent objects
should be implemented as follows:
<PRE>
SpreadSheet::SpreadSheet(char* name) : LockManager(ANDPERSISTENT)
{
  ArjunaName AN;

  AN.Register(name, this);

  . . .
}
</PRE>

<P>
The constructor that is used for accessing existing persistent
objects should be implemented as follows:
<PRE>
SpreadSheet::SpreadSheet(ArjunaName AN) :
					LockManager(*(AN.GetRefObjUid()))
{
  . . .
}
</PRE>

<H2> Changing Timeout Values</H2>

<P>
The default timeout for the <I>Arjuna</I> RPC is 5 seconds per
call. If this time is exceeded by a server executing an operation
then the server will stop the operation and return to a point
in the code (<I>getwork</I>) where it can await further requests.
Meanwhile the client will also have timed out and will retransmit
the request, as the server could have failed to receive the initial
RPC. If the server cannot execute the request in the time allowed
then the client call will fail after 2 retries. Obviously it is
possible that requests to perform operations on objects can take
longer than the default time allowed, in which case the timeout
period needs to be extended. The code below shows how the timeout
and retry values can be set on a per object basis:
<PRE>
ClientRpc  *RPCClient = new ClientRpc;
RPCClient-&gt;SetHost(hostname);
RPCClient-&gt;SetServiceName(servicename);
RPCClient-&gt;SetTimeout(3000);
RPCClient-&gt;SetRetry(1);
RpcControl *RPCCtl  = new RpcControl(RPCClient);
SpreadSheet ResearchFund(name, RPCCtl);
</PRE>

<P>
The above code changes the overall timeout period for a given
call on the object <TT>ResearchFund</TT> to be 30 seconds (3000
centiseconds). This represents the entire time taken after transmitting
the RPC request and including the retries that have been specified
(1 in this case). Thus, the first call will timeout after 15 seconds,
then a retry made (which will timeout after 15 seconds if no results
are obtained by then).
<H2> Persistent Object Constructors</H2>

<P>
Constructors, like all other operations, may (or may not) use
atomic actions in their implementations according to the implementor
of the constructor. However, the use (or absence) of an atomic
action within a constructor has certain affects of which the programmer
should be aware. In particular, using an action in a constructor
has a beneficial effect. In fact, the applications developed in
earlier chapters used atomic actions deliberately because of the
beneficial effects they had on the execution of the application.

<H3> Server-Side Action</H3>

<P>
Recall that the state of a persistent object is not written automatically
into the object store until the top-level action that manipulated
it commits. Thus by running a top-level action in the programmer
written constructor that is executed at the server we can ensure
that an object always has a persistent state in the object store
after the constructor ends.  This ensures that it has a valid
unique identifier (and state) that can be used and saved by other
persistent objects
<H3> Client-Side Action</H3>

<P>
Since atomic actions can be started at either the client or the
server (or both) then providing that an action is started at the
client <I>prior</I> to the creation of the object, a write lock
could simply be acquired in the constructor. Then, if this action
commits, the state of the persistent object will again be written
to the object store. This approach has almost the same functionality
as putting an action in the constructor, but allows the client
to control whether or not a persistent object can save its state
(in the original scheme the client lacks control over this, i.e.,
if the constructor returns successfully then the object's state
has been written to the object store). If the client aborts the
action then no state will be written. However, this method has
the disadvantage of being slower than the primary scheme, since
more RPC calls will have to be made between client and server
when the action either commits or aborts. Furthermore, it requires
the programmer to ensure that an action exists at the client before
constructing the object.
<H3> Non-Action Constructor</H3>

<P>
If the constructor does not contain an atomic action (and none
is in effect at the client) this has the effect of not saving
the object's state to the object store when the constructor ends.
This implies that any information about this object should not
be used (or recorded for future use) until the state has been
saved successfully. If, for example, the unique identifier of
an object was recorded for future use after the constructor has
completed, then if the object fails this unique identifier will
not reference a valid object (it will not exist in the object
store).
<H3> Saving the State of a New Persistent Object</H3>

<P>
It is important to ensure that any object has a <I>valid</I> state
before the <TT>save_state</TT> operation is called otherwise a
<TT>restore_state </TT>invocation could attempt to restore rubbish.
In <I>Arjuna</I>, newly created persistent objects are treated
differently to existing persistent objects where the <TT>save_state</TT>
and <TT>restore_state</TT> operations are concerned. For a new
persistent object (i.e., one that does not have a state in the
object store), the first time <TT>save_state</TT> would be called
(e.g., when the first write lock is set on the object) nothing
is done, i.e., <TT>save_state</TT> is effectively a null operation.
Likewise, the corresponding <TT>restore_state</TT> also does nothing.
This is because there can be no guarantee that the state of the
object is valid, and attempting to save such a state could cause
the application to fail.
<H2> The Interface Browser</H2>

<P>
As we have seen in <U><B>Chapter 4</B></U>, to be able to make
use of a remote object an application programmer must have access
to the interface description for that object. This interface description
can then be passed to the stub generation tool which will then
generate the necessary client and server code. To facilitate the
exchange of such object interface descriptions between multiple
application programmers, <I>Arjuna</I> provides an Interface Browser.
Since it is infeasible that every given node in a distributed
system may (or should) contain a copy of every objetc interface,
the Browser allows application programmers to obtain necessary
interface descriptions from the nodes on which they may reside.
<P>
<I>Arjuna</I> provides three interfaces to the Interface Browser:
<P>
   a plain text Browser which allows registering and obtaining
of interfaces;
<P>
   an Interviews Browser which allows registering and obtaining
of interfaces;
<P>
   a plain text Browser which allows interfaces to be obtained
- this is primarily intended for use in Makefiles.
<H3> Registering Interfaces.</H3>

<P>
When creating a class whose instances will be used remotely by
other users, the <I>interface description</I> should be registered
with the Interface Browser. The interface description and any
files that it may depend on should be packaged into a single file
(the UNIX <TT>shar</TT> or <TT>tar</TT> commands may be used for
this). Then the Interface Browser must be contacted by executing
either the Interviews or text version of the browser utility.
By following the instructions given it is then possible to register
the interface with the browser. The information required includes:
<P>
   a brief description of the interface to aid future developers
in selecting the correct interface for their needs;
<P>
   the name of the machine on which the interface resides;
<P>
   the location (pathname) of the interface description file.
<H3> Obtaining Interfaces.</H3>

<P>
An application programmer who wishes to make use of an existing
interface definition has two options. He can either browse the
database of interfaces to select the required one, or he can use
the interface selector intended for Makefile use.
<P>
If the former option is chosen, the programmer simply runs one
of the Interface Browser applications. This can then be used to
show the interfaces that are logged with it. When an interface
is selected, the user will be asked where to place the interface
when it is obtained from the remote node (e.g., /Applications/Spreadsheet/Client/spreadsheet.h).
<P>
If the programmer chooses to use the automatic version of the
interface selector then the following step must be taken. (Note
that the automatic selection of an interface is typically of most
use when run as part of the building of an application, i.e.,
invoked automatically by the <TT>make</TT> command). Invoke the
<TT>InterfaceDriver</TT> utility with the required interface name
as the parameter, e.g., <TT>InterfaceDriver Stack.h</TT>. The
utility will obtain the <I>first </I>interface in its database
with the desired name if the node on which the interface resides
is operational. It will then place the interface into the directory
from which the command was issued. As a further integration with
the <TT>make</TT> utility if a version of the desired interface
already exists in the directory then the new interface will only
be written if it has changed since the last time it was used.
<P>
Once the interface has been obtained the application programmer
can manipulate it to the required form (e.g., by un-taring the
file). By then passing the interface description to the stub generation
tool it is possible for the application programmer to make use
of the remote object.
<H1> Object Replication</H1>

<P>
This chapter describes the object replication mechanisms available
in <I>Arjuna</I>. These include basic object replication and complex
(composite) object replication.
<P>
<I>Note</I>: the replication mechanisms in the full 2.0 release
differ from those available in the beta release.
<H2> Basic Replication Concepts</H2>

<P>
Object replicas form a <I>replica group</I> to which all invocations
are typically sent (although read optimisations are typically
implemented, whereby only a single member of the replica group
is read from, and all available members are written to). Each
group is viewed by its users as a single logical entity, without
exposing its internal structure and interactions to users. Therefore,
groups provide a convenient and natural way to structure applications
into a set of members co-operating to provide a service.
<P>
<B>Figure 5.1: Replica Group Interactions</B>
<P>
The interactions with the replica group must be co-ordinated to
guarantee that only mutually consistent and up-to-date replicas
are used despite the presence of (a finite number of) failures.
The replication protocol is responsible for this, excluding failed
replicas from the group until they have been brought up-to-date,
and ensuring sufficient replicas are available to allow the group
to be used. <I>Arjuna</I> supports <I>strong consistency</I> protocols
which requires that all available replicas are required to be
identical.
<H3> Replication Protocols</H3>

<P>
There are basically two types of replication protocol:
<P>
<I>Active Replication:</I>  Every functioning member of a replica
group receives requests to the group and performs processing.
<P>
<I>Passive Replication:</I> Here, in contrast to the active replication
technique, only one member of the replica group, the <I>co-ordinator</I>
(<I>primary</I>), performs the processing and checkpoints its
state to the rest of the secondary replicas (its <I>backups</I>).
<P>
One of the advantages of passive replication is that it can be
implemented without recourse to any complex agreement and order
protocols (as only one replica carries out the computation at
any time). This is important for a system such as <I>Arjuna</I>,
which is required to be able to exploit the functionality offered
by commonly available distributed computing platforms. However,
its performance in the presence of primary failures can be substantially
poorer than under no failures, because the time it takes to detect
a failure and switch from the failed primary to the new primary
is not negligible. At present the default replication protocol
is passive replication, although <I>Arjuna</I> is capable of supporting
both replication schemes.
<H2> Replication in <I>Arjuna</I></H2>

<P>
With this view in mind, we have implemented the necessary infra-structure
within <I>Arjuna</I> to enable it to support both active and passive
replication of objects. We have done this by implementing a naming
and binding service for persistent replicated objects that ensures
that application only ever get to use mutually consistent copies
of replicas. The naming and binding service itself has been implemented
out of persistent objects whose operations may be invoked under
the control of atomic actions; that is how the service is capable
of providing the necessary consistency.
<P>
With reference to the <I>Arjuna</I> object model described in<U><B>
Chapter 1</B></U>, it is possible to replicated both an object's
methods and/or its state, giving rise to two types of replica
groups:
<P>
(i) <I>method (server) group</I>;
<P>
(ii) <I>state group</I>.
<P>
<B>Figure 5.2: Method and State Replica Groups</B>
<P>
Figure 5.2 shows one possible interaction obtained by replicating
an object's methods and its state, and illustrates how this need
not be a simple one-to-one mapping. The replication protocol guarantees
that the user's interaction with the method group is consistent,
and also guarantees that the method group's interactions with
the state group are consistent.
<P>
With reference to the object model outlined in<U><B> Section 2</B></U>,
the current replication protocol is based on replicating both
an object's state and its methods. The replication protocol uses
passive replication, whereby a single object server is active
(and possibly in use by multiple clients) and interacts with multiple
instances of the object's state. If the server should fail during
an atomic action then this will cause the action to abort. If
the action is then restarted it will obtain a new server as the
primary.
<P>
Figure 5.3 illustrates the server-state interaction:
<P>
<B>Figure 5.3: Object State Replication.</B>
<P>
To provide the object replication protocol we have extended the
naming and binding services provided by <I>Arjuna</I>. This has
been accomplished by modifying the Name Server, which maintains
the server group information, and by adding the GroupView Database,
which maintains the state group information. Application programmers
typically interact with the Name Server, while the objects themselves
interact with the GroupView Database.
<H2> Replicating a Persistent Object</H2>

<P>
We shall now consider how a persistent object's state can be replicated.
Initially we shall assume that only a single instance of the object's
methods are available (i.e., the server group has only one member).
<PRE>
//@NoRemote, @NoMarshall
enum MigratorStatus { GroupLocked, MovedOk,
				       FromNodeFailed, ToNodeFailed,
				       RegisterFailed, MoveFailed };
//@NoRemote, @NoMarshall
class Migrator
{
public:
    Migrator (int&amp;);
    ~Migrator ();

    void typeIs (TypeName);
    MigratorStatus moveFromTo (const char*, const char*,
								 const Uid&amp;, const Uid&amp;);

private:
	....
};
</PRE>

<H2> The Name Server</H2>

<P>
In general, naming and binding of persistent objects (whether
or not they are replicated) is a complex operation, depending
upon whether the persistent objects are to be shared amongst multiple
concurrent users. For example, if we suppose that multiple servers
for a given service have been registered at a naming service and
that each user will only make use of one such instance, then,
as long as concurrent clients operate on <I>different </I>persistent
object <I>states</I> it does not matter which server each client
uses. If, however, such clients are to manipulate the<I> same</I>
persistent object states then they must all make use of the same
server to guarantee serialisability. This is a problem whether
or not the persistent objects are replicated; replication simply
adds another level of difficulty.
<P>
In previous versions of <I>Arjuna</I>, it was implicitly assumed
that only a single instance (server) of a given service would
be available and registered at the name server, thus guaranteeing
serialisability in the presence of shared object states; if multiple
instances of a service were registered at the name server then
the application programmer had the responsibility of ensuring
that concurrent clients were bound to the same servers if they
were to manipulate the same object states. However, with the ability
now to manipulate state at remote object stores, such binding
is much more important, and the new version of <I>Arjuna</I> provides
support for this.
<P>
If server groups are registered at the name server (using the
ServerGroupEdit utility provided) then it is important to guarantee
that concurrent users bind to the same <I>active method</I> instances
for the above mentioned reasons. To impose this naming and binding
operation, <I>Arjuna </I>provides a class <TT>PrimaryNS</TT>,
which should be used if server groups are to be used in an application.
<PRE>
class PrimaryNS
{
public:
	PrimaryNS (int&amp; res);
	~PrimaryNS ();

	ActionStatus Begin ();
	ActionStatus End ();
	ActionStatus Abort ();

	Boolean FetchNameList (ArjunaName key);
	ArjunaName* GetPrimary ();
	Boolean RegisterPrimary ();
};
</PRE>

<P>
If the instance of the class is constructed successfully (indicated
by <TT>res</TT> returning 0) then it can be used to contact the
name server and obtain the server group associated with <TT>key</TT>
(via the <TT>FetchNameList</TT> operation). The binding operation
must be atomic to prevent possible conflicts from concurrent users;
as such the <TT>Begin</TT> operation must be invoked before any
other operation. If the <TT>GetPrimary</TT> operation is invoked
then it will return the identity of the method which is currently
in use, and this must be used in preference to any other method.
If this method is unavailable, another call to <TT>GetPrimary</TT>
will return the next method instance mentioned,  or <TT>NULL</TT>
otherwise. If no method instance is registered as being in use,
then the first instance will be returned.
<P>
Once a method instance has been successfully created this must
be registered at the name server using the <TT>RegisterPrimary</TT>
operation. The <TT>End</TT> operation can then be invoked to commit
the changes made to the name server. The <TT>Abort</TT> operation
can be invoked to undo any changes.
<P>
Because the current replication implementation is based on passive
replication, the <TT>PrimaryNS</TT> class enforces this policy,
only allowing a single method instance to be marked as active
at the name server. Future replication protocols will require
the provision of similar naming and binding classes.
<P>
<I>Note:</I> the Name Server is now an <I>Arjuna </I>object to
assist in the above mentioned naming and binding operation, and
all interactions with it can/should be performed within atomic
actions. This now means that when registering (and obtaining)
instances of the <TT>ArjunaName </TT>class it is important to
realise that this will result in the creation of a Name Server.
Thus, it is no longer possible to create and delete an <TT>ArjunaName
</TT>instance at will, e.g., delete within an atomic action, if
the <TT>LookUp </TT>operation, two<TT> Register </TT>operations,
or the constructor which takes a <TT>const char*</TT>, have been
used.
<H2> The GroupView Database</H2>

<P>
The GroupView Database maintains information on replicated object
states, i.e., <I>state replica groups</I>. Each entry represents
an object <I>group view</I>, i.e., each entry (Gi) is a list of
the form &lt;Ui, Ni&gt;, where Ui is the Uid of a replica state
and Ni is the name of the node on which it resides. A given entry
is accessed via its unique name Gi, which is also an instance
of a Uid. If the name of an entry stored at the database is passed
to a persistent object at activation time then the object will
read from the group and write to the group. As long as a single
replica remains available in the group then the group as a whole
will be considered available and the object will remain functioning.
<H3> Creating Group Views</H3>

<P>
Group views can be created/modified/deleted using the GroupViewDriver
utility program provided. This will assign a new group view its
own Uid and the user can then add the required replicas and their
locations, or they can be deleted or modified in a number of ways.
By following the menu-driven instructions, group views can be
manipulated as desired. By using the Uid of the group view in
the constructor of the persistent object, i.e., for object activation
then, when the object is activated, it will make use of the replicated
states.
<P>
Although we shall be considering replica group interactions, it
is entirely possible to use the facilities provided to create
an object which only has a single state instance which is desired
to be physically remote from the object server. We shall consider
this as a specific instance of the more general replica group
interactions.
<P>
<I>Note:</I> as mentioned earlier, the default scheme for Arjuna
objects is not to make use of the GroupView Database and to use
the object store local to the node where the method instance is
currently executing. If, however, this default is overridden (see<U><B>
Section 3.3</B></U>) and an entry for a given group view cannot
be found in the database then <I>Arjuna </I>will again default
to inspecting the local object store for the object state unless
otherwise specified (see<U><B> Section 3.3</B></U>).
<H3> Excluding Group Members</H3>

<P>
Associated with each replica mentioned in a group view is a flag
which indicates whether or not the replica is available. Whenever
a replica is detected to have failed, and such a failure would
render the replica out-of-date, the replica is marked as unavailable
at the database (it is <I>excluded</I> from the group view) and
it will then no longer be accessed. When the failed node recovers
it should bring the replica up-to-date before it can &quot;rejoin&quot;
the group view. <I>Note:</I> in 2.0 Beta the crash recovery mechanism
does not do this, and once a replica is excluded from a group
view it will never automatically be rejoined or brought up-to-date.
This can be done manually by making use of the GroupViewDriver
program.
<H3> Failure Masking</H3>

<P>
If the failure of replicas are detected when the object is first
used within an application atomic action then those replicas will
be excluded from the database group view. If further failures
occur after this exclusion has occurred then currently <I>Arjuna</I>
cannot mask them and guarantee consistency between possible concurrent
users of the group, and therefore the action will be forced to
abort. If the atomic action is restarted then the new replica
failures will be reflected at the GroupView Database and, provided
no further replica failures occur after the database update, the
action will be able to commit.
<H2> HasRemoteState Operation</H2>

<P>
To be able to make use of remote (and possibly replicated) object
states it is necessary to instruct <I>Arjuna</I> objects to make
use of the GroupView Database to obtain information on the location(s)
of the state(s) to be used at activation time. To be able to do
this, the <TT>StateManager </TT>class of <I>Arjuna</I> has been
modified with two new methods:
<PRE>
class StateManager
{
public:
	...
	virtual Boolean HasRemoteState ();
	virtual char* storeName ();
	...
};
</PRE>

<P>
If the operation <TT>HasRemoteState()</TT> returns <TT>TRUE</TT>
then the GroupView Database is used. The operation <TT>storeName()</TT>
indicates where to place a new persistent object's state, and
the default location (i.e., if this method is not redefined in
the derived class) is the same node as the object method is currently
run from. An example redefinition of <TT>HasRemoteState</TT> is
shown in<U><B> Section 3.5.</B></U>
<P>
Without redefining at least <TT>HasRemoteState</TT> then the GroupView
Database will never be accessed by instances of the class and
<I>Arjuna </I>will inspect the local object store for the object's
state. This is the reason why all previous <I>Arjuna </I>applications/examples
continue to function with the new system without modification.
<H2> Registering new replica groups</H2>

<P>
Although the GroupView Database can be modified directly using
the GroupViewDriver program to create/delete group views, this
approach requires such groups to be created and registered outside
of the program they are to be used within. <I>Arjuna </I>provides
another method of creating and registering group views which can
be used within an application program through the <TT>Register</TT>
class:
<PRE>
class Register
{
public:
	Register ();
	~Register ();

	void RegisterGroupUid (const Uid&amp;);
	void RegisterTypeName (TypeName);

	void RegisterObject (const Uid&amp;, TypeName);
	Boolean ReplicateState (ReplicaData*);

private:
....
};
class ReplicaData
{
public:
	ReplicaData ();
	ReplicaData (const char*);
	~ReplicaData ();

	char hostName[MAXHOSTNAMELEN];
	
	ReplicaData&amp; operator= (const char*);
	ReplicaData&amp; operator= (const ReplicaData&amp;);

	ReplicaData* next;
};
</PRE>

<P>
The type of the object (e.g., &quot;<TT>/StateManager/LockManager/SpreadSheet</TT>&quot;)
to be replicated must be supplied to the instance of the <TT>Register
</TT>class using either <TT>RegisterTypeName</TT> or as the second
parameter to the <TT>RegisterObject </TT>method. The desired group
identifier (Uid) should be supplied either using <TT>RegisterGroupUid</TT>
or as the first parameter to <TT>RegisterObject</TT>.
<P>
<I>Note:</I> that the Uid of an existing object can be supplied,
even the Uid of one of the group members. As will be shown in
<U><B>Section 3.5</B></U> this enables an application programmer
to convert an existing non-replicated object into a replicated
object with the same name. Existing applications need not be modified
to make use of this as long as they continue to use the same Uid,
i.e., such conversion will be transparent.
<P>
Finally the list of the group members to be created should be
supplied to the <TT>ReplicateState </TT>method (with the head
of the list as the state to be replicated). The<TT> hostName </TT>entry
of the<TT> ReplicaData </TT>class refers to the name of the node
where a replica is to be placed (e.g., <TT>&quot;ulgham&quot;</TT>).
<P>
The <TT>Register </TT>object will attempt to create the desired
number of replicas by reading the state to be replicated from
the first entry in the list supplied and writing it to as many
of the other list elements as possible. The replicas which were
successfully created will form the replica group and will be registered
at the GroupView Database.
<P>
<I>Note:</I> in later releases of the <I>Arjuna</I> software the<TT>
Register</TT> class will be modified to improve the way in which
groups are created, e.g., it will be possible to specify the minimum
number of replicas which must be created for the group to be formed.
<H2> Example</H2>

<P>
We shall now give an example of how to use the replication (and
remote object store) facilities provided by <I>Arjuna</I>. Consider
the example <I>Arjuna</I> class defined below:
<PRE>
class Replica : public LockManager
{
public:
	Replica (int&amp;);
	Replica (Uid&amp;, int&amp;);
	~Replica ();

	Boolean change (int);
	Boolean value (int&amp;);

	void makeReplicated (Boolean);
	
	Boolean HasRemoteState () const;

	virtual Boolean save_state (ObjectState&amp;, ObjectType);
	virtual Boolean restore_state (ObjectState&amp;, ObjectType);
	virtual const TypeName type () const;

private:
	int number;
	Boolean Replicated;
};
</PRE>

<P>
The state of the class <TT>Replica</TT> consists of a single integer
which can be modified (<TT>change</TT>) and read (<TT>value</TT>).
The variable <TT>Replicated</TT> is used to indicate whether a
given instance of this class interacts with either a replica group
or a single object state (i.e., traditional, non-replicated <I>Arjuna</I>).
The example to be given will create and then use a replica group.
For simplicity we shall not show all of the method implementations
for the <TT>Replica </TT>class, only those which are of interest.
<PRE>
Replica::Replica (int&amp; res) : LockManager(ANDPERSISTENT)
{
	AtomicAction A;

	A.Begin();

	Replicated = FALSE;				// default is non-replicated object
	number = 0;

	if (setlock(new Lock(WRITE), 0) == GRANTED) // object activation
	{
		if (A.End() == COMMITTED)
			res = 0;
	}
	else
	{
		A.Abort();
		res = -1;
	}
}
Replica::Replica (Uid&amp; u, int&amp; res) : LockManager(u)
{
	res = 0;
	number = 0;
	Replicated = FALSE;
}
</PRE>

<P>
Note that the second constructor does not activate the object
(i.e., no lock is set within it which would cause the state to
be read/writted).
<P>
All instances of the <TT>Replica</TT> class will initially be
non-replicated, i.e., traditional <I>Arjuna</I> objects. This
is indicated by the fact that <TT>Replicated</TT> is set to <TT>FALSE</TT>.
<PRE>
Boolean Replica::HasRemoteState () const { return Replicated; }
void Replica::makeReplicated (Boolean flag) { Replicated = flag; }
</PRE>

<P>
If the <TT>makeReplicated</TT> method is invoked with <TT>flag</TT>
set to <TT>TRUE</TT> then at object activation time the GroupView
Database will be invoked to obtain information on the object's
Uid. We shall now examine the application program. Note that for
simplicity we shall omit the error checking code which would normally
be incorporated into the program:
<PRE>
1 void main ()
2 {
3	const int numberReplicas = 2;
4
5	Replica *loneObject = 0; *objectGroup = 0;
6	Uid u_id;
7	Register* reg = 0;
8	AtomicAction A, B, C;
9	ReplicaData *head = 0, *ptr = 0;
10	Boolean result = FALSE;
11	int res = -1, value;
12
13	loneObject = new Replica(res);
14
15	A.Begin();
16
17	(void) loneObject-&gt;change(2);
18
19	A.End();
20
21	u_id = loneObject-&gt;get_uid();
22	head = new ReplicaData;
23
24	// set up list of replicas to be created, with head of list
25	// as object to be replicate - loneObject in this case
26
27	reg = new Register;
28
29	B.Begin();
30
31	reg-&gt;RegisterObject(u_id, loneObject-&gt;type());
32	(void) reg-&gt;ReplicateState(head);
33
34	B.End();
35	delete reg;
36
37	res = -1;
38	objectGroup = new Replica(u_id, res);
39	objectGroup-&gt;makeReplicated(TRUE);
40
41	C.Begin();
42
43	res = -1
44	value = objectGroup-&gt;value(res);
45	cout &lt;&lt; &quot;value returned is &quot; &lt;&lt; value &lt;&lt; &quot;\n&quot; &lt;&lt; flush;
46
47	C.End();
48	// cleanup and delete objects
49 }
</PRE>

<P>
Lines 3-11 simply set up the various constants and variables used
in the main program. We shall create two instances of the <TT>Replica
</TT>class: the first one (<TT>loneObject</TT>) will be a new
non-replicated <I>Arjuna</I> object with the state resident on
the same node as the server. The second instance (<TT>objectGroup</TT>)
will also have a single server on the same node as <TT>loneObject</TT>
but it will have a replica group managing its object state. The
members of the replica group will be copies of the<TT> loneObject</TT>
state.
<P>
Line 13 creates a new persistent object with an initial state
of 0 (i.e.,. <TT>number</TT> is 0).
<P>
Lines 15-19 start and end a top-level atomic action, and within
this action the state of the new persistent object is modified.
<P>
Line 21 obtains the Uid of the created persistent object. This
will be the Uid of the replica group and will be used at object
activation time in exactly the same way it would normally be used
for re-creating the persistent object.
<P>
Lines 21-25 builds the list of replicas to be created, with the
information for the state to be replicated (<TT>loneObject</TT>)
at the head of the list.
<P>
Line 27 creates an instance of the <TT>Register</TT> class which
will handle the creation and registering of the new replica group.
<P>
Lines 29-34 create the new state replica group and register it
at the GroupView Database.
<P>
Lines 37-38 create a new instance of the <TT>Replica </TT>class
using the group Uid obtained from <TT>loneObject</TT>.
<P>
Line 39 instructs the <TT>objectGroup</TT> object to inspect the
GroupView Database at activation time for information on the replica
group which manages its state.
<P>
Lines 41-48 makes use of the new object and hence the replica
state group.
<H2> Replicating the Name Server and GroupView Database</H2>

<P>
Both the Name Server and GroupView Database can be replicated
to improve their availability. However, the replication method
used for these <I>Arjuna </I>services is slightly different than
that described previously, being based on active replication.
<P>
At present the Name Server and GroupView Database are implemented
as a single <I>Arjuna </I>object (although their individual identities
are preserved and locks held on one do not affect the other).
If their availability is to be improved then copies of the states
should be placed on separate nodes. The locations of these copies
should then be noted on all nodes which will run <I>Arjuna </I>applications.
This is accomplished by using the NameInfoDriver utility program
provided, which creates a database of registered name servers.<I>
Note: </I>if such a database does not exist on a given node then
any accesses of the name server will attempt to use a local copy
(creating a new, empty name server if one does not exist).
<P>
To use the Name Server (or GroupView Database) the application
programmer should make use of the<TT> NSInterface </TT>class provided.
This will hide any replication of the service which may (or may
not) exist. In this way it will be possible to alter the degree
of replication without changing any programs which make use of
the service.
<PRE>
class NSInterface
{
	NSInterface (int&amp;); // access existing instances or create new instance
	NSInterface (Boolean&amp;);	// create new instance
	~NSInterface ();

	void StoreName (Boolean&amp;, Buffer, Buffer);
	void FetchName (Boolean&amp;, Buffer, Buffer&amp;);
	void RemoveName (Boolean&amp;, Buffer);
	void ReplaceName (Boolean&amp;, Buffer, Buffer);
	void GetNextName (Boolean&amp;, Buffer&amp;, Boolean&amp;);
	void Restart (Boolean&amp;);
};
</PRE>

<H1> Object Clustering</H1>

<H1> Notes on Program Structuring and Debugging</H1>

<H2> General</H2>

<P>
Due to the extra failure modes introduced by distributing applications,
certain programming conventions should be used to ensure the validity
of the values obtained as a result of an RPC operation. Note that
when exception handling is introduced into C++ many of these conventions
will be altered or removed.
<P>
On the server side, each method should have a reference value
that will contain the status of the operation. This status value
should always be changed within the method, to denote that the
RPC call succeeded. The actual value given denotes the status
of the method operation itself. The convention generally used
by the <I>Arjuna</I> developers is to make the status an integer
reference value and pass this reference value in with a value
of 0. If this value remains unchanged, an RPC failure (timeout)
has occurred. If the value is not 0, it implies that the RPC call
succeed. In this case the value assigned gives further information,
with negative values denoting that the method failed, whereas
positive values denote that the method succeeded.
<P>
On the client side the variable that will contain the status value
must be initialised with the appropriate value prior to each call
being made, and the return value checked after each call is completed,
before using any of the other values that may have been obtained
as a result of the call. If the call was not successful, those
other values may not be valid.
<H3> Server</H3>

<P>
 For each persistent object, the following constructors are required
(at a minimum): (i) for using an existing persistent object; (ii)
for creating a new persistent object.
<P>
 Never use function return values for methods exported by a remote
object to a client, unless a dummy parameter has determined that
the operation was performed correctly. If an RPC failure occurs,
the function return value received by the client will contain
a random, possibly illegal, value.
<H3> Client</H3>

<P>
 The scope of an object must be the same or greater than the scope
of any atomic actions that manipulate it. This is required since
atomic action aborts/commits etc. need to communicate with the
server that would no longer exist if the object had gone out of
scope and been destroyed.
<P>
 Remember that reference (and pointer) values may be accessed
by the RPC mechanism before being passed to the server (unless
marked <I>@Out)</I>; therefore reference variables must be correctly
initialised before a call.
<H2> When Things Go Wrong</H2>

<P>
Debugging a distributed system is not an easy process, due to
the varied number of failures which can occur. This section attempts
to give a methodology for tracking down the location of the problem,
at least to a particular system component.
<H3> The Client Startup</H3>

<P>
The client starts, but a warning message is printed stating that
server initialisation has failed. This message will probably be
of the form
<P>
WARNING: ClientRajdoot_rpc::Initiate() : Failed
<P>
If the above warning message is obtained, then the following sequence
of actions should be performed:
<P>
  Check that the host on which the server is required is operational.
<P>
  Check that the server host is running the RPC manager daemon.
<P>
  Check that the server binary has been installed on the server
host.
<P>
  Check that the server binary is readable and executable to the
manager daemon.
<P>
  Check to see whether or not the server is running, (this can
be accomplished by making use of the Unix command ps to show what
processes are running). If the server is running, it indicates
that a timeout occurred during the server initiation. This can
be corrected by increasing the timeout for server initiation,
as shown in<U><B> section 6.2.</B></U>
<P>
  Check that there are sufficient shared memory segments and semaphores
available (see Section<U><B> 5.2.1.1.</B></U>).
<P>
If these checks are passed the problem lies in the initialisation
portion of the server, which occurs before the server object constructor
is called. This implies that there is a problem with either the
stub generated code for the server, or a problem with the <I>Arjuna</I>
libraries. 
<H3> Shared Memory and Semaphore Recovery</H3>

<P>
If <I>Arjuna</I> servers or clients terminate abnormally, it is
possible that the shared memory segments (and/or semaphores) allocated
to them will remain assigned. This can eventually result in an
exhaustion of the available shared memory segments and/or semaphores.
To prevent this, the shared memory allocation should be checked
after such an event. This is done by the following process:
<P>
  Ensure that no other <I>Arjuna</I> servers are running.
<P>
  Check the shared memory allocation using the Unix command &quot;ipcs&quot;.
Any shared memory segments and/or semaphores allocated will need
to be deallocated (cleaned).
<P>
To deallocate the shared memory segments/semaphores:
<P>
  Check again that no servers are running.
<P>
  Terminate the <I>Arjuna</I> manager daemon. This will prevent
any servers from starting up.
<P>
  Run the <I>Arjuna</I> utility &quot;ipcclean&quot;.
<P>
  Restart the manager.
<H3> Server Request Failures</H3>

<P>
These are caused by communication timeouts, and can have several
causes:
<P>
a) The server was not there to service the request
<P>
b) The server has died while servicing a particular request.
<P>
Either of these two causes denotes that there are problems with
the server code.
<P>
c) The request made to the server required extensive computation,
that required more time to complete than allocated on the timeout.
<P>
d) The host on which the server is running is overloaded.
<P>
e) The host on which the server is running has failed.
<P>
These causes require the timeout to be changed. Case c) only requires
that the default timeout period be increased when making that
specific server call, whereas case d) requires the timeout period
to be extended for all calls to that particular server.
<H2> General Debugging</H2>

<P>
Debugging of distributed applications makes the use of conventional
debugging tools difficult and unrewarding, particularly if the
problem is suspected to lie with the server code. A solution to
this problem is to insert tracing (output) commands in the server
code. <I>Arjuna</I> provides a debugging stream class that can
be used to produce these messages. In general, there should be
tracing messages produced on entry to each method, but this can
be tailored as required.
<P>
To make the best use of this tracing output, the manager should
be started with the '-d' option; this causes two text files to
be created (in <TT>/tmp</TT>) for each server, containing respectively
the output and error messages generated during the running of
the server. If the manager is not started with the -d option,
all the output is directed into the manager's own error and output
files. 
<H2> Object Persistence and Object States</H2>

<P>
<I>Arjuna's</I> object store is currently organized according
to the user's applications class hierarchy. Every object is represented
as a single file, named according to its Uid; 3 fields each separated
by a dot. So the state of an instance of the user class Foo, derived
from LockManager would be found in the directory .../ObjectStore/StateManager/LockManager/Foo
and would be named (say) 128.240.0.165:1409322690.696859607.759344

<P>
Currently in <I>Arjuna</I> persistent objects are extremely persistent.
There are no means of destroying a persistent object from within
<I>Arjuna</I>. Consequently the user himself must manage this
task. 
<P>
There is no symmetry between the <TT>save_state</TT> and <TT>restore_state</TT>
function activations; there may be zero or more activations of
<TT>save_state</TT> per <TT>restore_state</TT>. Users should not
assume that an object goes inactive after a <TT>save_state</TT>.
<H2> Arjuna Debugging</H2>

<P>
Both the RPC Module, and the <I>Arjuna</I> class hierarchy can
be made to produce diagnostics. The <I>Arjuna</I> libraries contain
diagnostics that can be produced by compiling the source of the
library with &quot;-DDEBUG&quot;. These diagnostics will give
information about the events happening within <I>Arjuna</I>  (i.e,
atomic action creation, abstract record operations, . . .), and
are produced on the standard C++ stream <I>cout</I>.
<P>
The diagnostic messages produced are controlled by the <TT>_arjuna_debug</TT>
variable (a pointer to an instance of the class DebugController).
<PRE>
class DebugController
{
public:
 	/* Constructors and destructor */
 	DebugController (DebugLevel = NO_DEBUGGING,
						FacilityCode = FAC_ALL,
						VisibilityLevel = VIS_ALL);
  	/* non-virtual public functions */
	void set_all (DebugLevel, FacilityCode, VisibilityLevel);
	void set_debuglevel (DebugLevel);
	void set_facility (FacilityCode);
	void set_visibility (VisibilityLevel);
	
	Dbg_Ostream&amp; stream ();

private:
	 . . . 
};
</PRE>

<P>
The operations <TT>set_all</TT>, <TT>set_debuglevel</TT>, <TT>set_facility</TT>
and <TT>set_visibility</TT> can be used to control precisely what
diagnostics will be produced. Since each debugging level is represented
by a single bit in the controller, debugging of multiple levels
can be produced by OR-ing together the fields, for example:
<PRE>
#ifdef DEBUG
#include &lt;Common/Debug.h&gt;
#endif
. . .
#ifdef DEBUG
	_arjuna_debug-&gt;set_all(FULL_DEBUGGING, FAC_USER1, VIS_ALL);
#endif
</PRE>

<P>
The permissible values of enumerated type<TT> DebugLevel</TT>
are:
<P>
NO_DEBUGGING:   No diagnostics.
<P>
CONSTRUCTORS:   Diagnostics from constructors.
<P>
DESTRUCTORS:   Diagnostics from destructors.
<P>
CONSTRUCT_AND_DESTRUCT: Diagnostics from constructors and destructors.
<P>
FUNCTIONS:   Diagnostics from functions (includes the RPC    
debugging).
<P>
OPERATORS:   Diagnostics from operators.
<P>
FUNCS_AND_OPS:   Diagnostics from functions, and<BR>
    operations.
<P>
ALL_NON_TRIVIAL:  Diagnostics from all non-trivial operations.
<P>
TRIVIAL_FUNCS:   Diagnostics from trivial operations, <BR>
    and functions.
<P>
TRIVIAL_OPERATORS:  Diagnostics from trivial operations, <BR>
    and operators.
<P>
ALL_TRIVIAL:   Diagnostics from all trivial <BR>
    operations.
<P>
FULL_DEBUGGING:  Full diagnostics.
<P>
The permissible values of enumerated type <TT>FacilityCode</TT>
are:
<P>
FAC_BASIC_RPC:   Basic RPC Interface classes.
<P>
FAC_ATOMIC_ACTION:  Atomic action management classes.
<P>
FAC_CONCURRENCY_CONTROL:Concurrency control classes.
<P>
FAC_BUFFER_MAN:  Buffer management classes.
<P>
FAC_ABSTRACT_REC:  Abstract record classes.
<P>
FAC_OBJECT_STORE:  Object store classes.
<P>
FAC_STATE_MAN:   State management classes.
<P>
FAC_ACTION_RPC:  Action RPC interface classes.
<P>
FAC_SHMEM:   Shared memory classes.
<P>
FAC_GENERAL:   General classes.
<P>
FAC_USER1-6   User levels 1 through 6.
<P>
FAC_ALL:    Enable all diagnostics.
<P>
The permissible values of the enumerated type<TT> VisibilityLevel</TT>
are:
<P>
VIS_PRIVATE:   Private operations.
<P>
VIS_PROTECTED:   Protected operations.
<P>
VIS_PUBLIC:   Public operations.
<P>
VIS_ALL:    All operations.
<P>
The level of debugging produced by the <I>Arjuna</I> debug system
can be controlled by three environment variables. These variables
are:
<P>
DEBUG_LEVEL
<P>
DEBUG_FAC
<P>
DEBUG_VIS
<P>
Each of these variables must be set to a 4 digit hex value (0-9,
A-F) that controls the amount of information required. As an example,
the following values instruct <I>Arjuna</I> to produce the maximum
amount of debugging output:
<P>
 (using csh)
<P>
 setenv DEBUG_LEVEL FFFF<BR>
setenv DEBUG_FAC   FFFF<BR>
setenv DEBUG_VIS   FFFF
<P>
(using sh)
<P>
 set DEBUG_LEVEL FFFF; export DEBUG_LEVEL<BR>
set DEBUG_FAC   FFFF; export DEBUG_FAC<BR>
set DEBUG_VIS   FFFF; export DEBUG_VIS
<P>
The value to be assigned to each variable is computed by OR-ing
together the desired levels of information required. For example,
if the visibility level required is to produce debugging output
for both VIS_PRIVATE and VIS_PROTECTED, the value to be set into
DEBUG_VIS should be 0003. Note that these environment values can
be overridden within servers and clients, though this is generally
not recommended.
<P>
There is a utility called SetDebug that has been provided for
simplifying this procedure.
<H3> User Class Diagnostics</H3>

<P>
If the user wishes to produce diagnostics there are <TT>FacilityCodes</TT>
that are reserved for this purpose. For example:
<PRE>
#ifdef DEBUG
#include &lt;Common/Debug.h&gt;
#endif
. . .
void UserClass::Set()
{
#ifdef DEBUG
	debug_stream &lt;&lt; FUNCTIONS &lt;&lt; FAC_USER1 &lt;&lt; VIS_PUBLIC;
	debug_stream &lt;&lt; &quot;UserClass::Set()\n&quot;;
#endif
...
}
</PRE>

<P>
If the requested <TT>DebugLevel</TT>, <TT>FacilityCode</TT>, and
<TT>VisibilityLevel</TT> match that currently in effect then the
diagnostic message contained in debug_stream will be printed.
<H3> Other Useful Utilities</H3>

<P>
The following utilities could be found useful when debugging applications:
<P>
  etherfind:  Can monitor particular packets on Ethernet.
<P>
  adb:   General-purpose debugger.
<P>
  dbx:   Source-level debugger.
<P>
  dbxtool:  SunView interface for the dbx source-level<BR>
   debugger.
<P>
  gdb:   GNU's Source-level debugger.
<P>
For more information on these utilities see the corresponding
UNIX manual pages.
<H1> Crash Recovery</H1>

<P>
In <I>Arjuna</I>, atomic action themselves are represented by
objects with internal state. The atomic action objects are persistent,
but not recoverable in any real sense since they are used to implement
the recovery scheme. The persistent state of the atomic action
is the commit/abort decision with an <I>intentions list</I> that
identifies the objects that are affected by this decision. The
intentions list is composed from instances of classes derived
from the <I>AbstractRecord</I> class.
<H2> Crash Detection and Recovery</H2>

<P>
The <I>Arjuna</I> system assumes that nodes in the network are
fail-silent. That is, they either function correctly, or fail
completely. Through the communications sub-system, the run-time
system becomes aware of failed nodes (i.e., nodes that are not
responding to communications requests). At present, we make no
attempt to detect individual process failures on a node. If a
server is not responding, the communications system will attempt
to determine if the node on which that server is executing has
failed. If the node is still accessible, the server is presumed
to be still available. Future versions of the <I>Arjuna</I> software
will take account of finer-grained failures.
<H3> Orphans and Deadlines</H3>

<P>
When a node fails, there are two situations that may (possibly
simultaneously) arise: a client has failed or a server has failed.
When a client fails, the servers with which it had been communicating
become <I>orphans</I>. When a server fails, the client may proceed
unaware of the failure until it comes to perform another operation
on that object, or commit the action, when the failure will be
discovered.
<P>
Since operation invocations are always initiated by clients, orphaned
servers might wait indefinitely for a next or terminating request
to come from a client. To detect that no further request is ever
going to come, servers must periodically poll their client (nodes)
to verify that they are still functioning. In <I>Arjuna</I>, this
mechanism is incorporated into the RPC  communication sub-system
(called <I>Rajdoot</I>). When a server has been idle for more
than some timeout period, the communication sub-system automatically
polls the client node to ensure that it is functioning. If the
node is down, the server is terminated. To protect against a (false)
conclusion about the state of the client node, the communication
sub-system maintains a <I>crash count </I>on stable storage that
is incremented every time a node boots. The communication system
on the server node records the crash count of each client node
when communication is first established. Subsequent checks on
node status will compare crash counts to detect the state change.
If a server is taking part in the commit protocol, and it is in
the second phase, then it must follow the rules of the protocol
and commit or abort as the case may be, even if it is an orphan.
Therefore, the communication sub-system does not terminate orphaned
servers who are in the second phase of this protocol.
<P>
All RPCs in the <I>Arjuna</I> system carry a deadline, indicating
to the server the maximum time available for performing the computation.
The deadline mechanism is necessary to avoid the situation by
which a client waits for ever for a call to return from a live
server (say the server is in an infinite loop). Expiration of
the deadline at a server causes that server to abort its current
atomic action.
<H3><U> Recovering from a Crash</U></H3>

<P>
<U>When a crashed node recovers, there may be objects on the crashed
node that are in an indeterminate state (since the node missed
the commit or abort message that would determine their state).
Some action is required to bring all such objects to a consistent
state.</U>
<P>
<U>Two programs are employed in recovering from a crash: (i) a
<I>recovery manager</I> whose job it is to seek out files recording
incomplete atomic actions and to resolve the commit/abort decisions
for these actions, and (ii) a <I>recovery demon</I> listening
on a well-known port for requests from recovery managers for the
final dispositions of atomic actions. (Note: the current crash
recovery system has been designed as a temporary measure; a substantial
overhaul is in progress).</U>
<H4><U> The Recovery Daemon</U></H4>

<P>
<U>The recovery daemon is an atomic-action result server. It listens
on a well-known port for requests from recovery managers (containing
servers) for commit/abort decisions on atomic actions. A request
need supply only the unique identifier of an atomic action. If
the recovery demon finds a file for that unique identifier in
the AtomicAction directory of its node then it replies favourably
and the caller will decide to commit the effects of the atomic
action on its node. If no such entry is found then either the
action must have aborted This is known as the &quot;presumed abort&quot;
protocol.</U>
<H4><U> The Recovery Manager</U></H4>

<P>
<U>The recovery manager is started at boot time. The recovery
manager's first task is to find any atomic actions left in phase-2
and to terminate them if possible by trying to contact the co-ordinating
node for the action and communicating with its recovery demon.
The recovery manager must repeat its task periodically as some
or all the co-ordinator nodes involved in incomplete atomic actions
may be unavailable. These must be retried indefinitely.</U>
<P>
<U>Any objects on a recovering node that are in a &quot;dirty&quot;
state, that is, were modified by actions not yet completed, must
remain unavailable until the fate of those actions becomes known.
The recovery manager ensures this as follows. Each recovery scan
(both at boot time and at periodic wakeups) begins by finding
all objects in abandoned actions and renaming them before attempting
to recover them. These objects will then be effectively locked
simply by being inaccessible to ordinary Arjuna programs. </U>
<H4><U> The AtomicAction directory</U></H4>

<P>
<U>Files in this directory are named by means of &quot;stringified&quot;
uids. Their contents are ignored. The mere presence of a file
here indicates that the AtomicAction with that uid successfully
completed the prepare phase of its commit protocol and the action
can thus be committed. If a co-ordinator for an AtomicAction with
uid x is known to have run on node n, and the AtomicAction directory
on node n contains no entry for uid x, then this implies that
the action was aborted.</U>
<H4><U> The ServerAtomicAction directory</U></H4>

<P>
<U>In this directory non-coordinator &quot;prepare&quot; records
are saved. The following data is kept:</U>
<P>
<U>  The atomic action uid.</U>
<P>
<U>  The node name of the coordinator. This is needed to know
which recovery demon to ask about the final disposition of the
atomic action.</U>
<P>
<U>  The pid of the server process that created this record. This
allows the recovery manager to verify that a record it finds actually
needs to be recovered. This way it can run periodically instead
of only at reboot time. (Periodic scanning is needed to perform
recovery for a server node that never crashes serving a client
that does.)</U>
<P>
<U>  Object pathnames. The full pathname (i.e, the concatenation
of object store directory, type directory, and stringified uid)
of every object modified by this server.</U>
<P>
<U>To summarise: the recovery manager and recovery daemon are
background processes that run continuously on each node in an
<I>Arjuna</I> system. They cooperate to perform recovery of objects
that are in an ambiguous state (due to a crash during commit processing).</U>
<H1> The ObjectStore Class</H1>

<P>
There are two implementations of the object store as has already
been described:
<P>
(i) the disk based object store (<TT>LocalPersistentObjectStore</TT>);
<P>
(ii) the in-memory based object store (<TT>LocalVolatileObjectStore</TT>).
<P>
Both of the object store implementations are derived from the
base <TT>ObjectStore</TT> class. This defines the minimum operations
which must be provided in order for an object store implementation
to be used by <I>Arjuna</I>.
<PRE>
class ObjectStore
{
public:
    virtual ~ObjectStore ();

    /* The real interface */

	virtual Boolean commit_state (const Uid&amp;, const TypeName) = 0;
	virtual ObjectState *read_state (const Uid&amp;, const TypeName) = 0;
	virtual ObjectState *read_uncommitted (const Uid&amp;,
											 const TypeName) = 0;
	virtual Boolean remove_state (const Uid&amp;, const TypeName) = 0;
    virtual Boolean remove_uncommitted (const Uid&amp;,
										  const TypeName) = 0;
    virtual Boolean write_committed (const Uid&amp;,
							const TypeName, const ObjectState&amp;) = 0;
    virtual Boolean write_state (const Uid&amp;, const TypeName,
								   const ObjectState&amp;) = 0;
 
    virtual ObjectState *allObjUids (const TypeName) = 0;

    virtual const TypeName type () const = 0;
   
    static ObjectStore* create (const TypeName, const char* = 0);
    static void destroy (ObjectStore*&amp;);
}
</PRE>

<P>
The object store class is stateless in that it simply fetches
instances of <TT>ObjectState</TT> from the object store and returns
them to the real object. As such, although instances of each type
of object store can be created as with any C++ object, if the
<TT>create</TT> and <TT>destroy</TT> methods of <TT>ObjectStore</TT>
are used, with an appropriate parameter indicating the type of
store required, <I>Arjuna</I> only ever creates one instances
of each type and automatically shares these instances.
<H2> Persistent Object Store</H2>

<P>
The original version of the object store as provided in prior
releases was simple but slow. Much of this poor performance stemmed
from the use of pairs of files to represent objects (the shadow
version and the committed version) and that the files where opened,
locked, operated upon, unlocked and closed on every interaction
with the object store. Thus significant portions of time were
spent in the system simply opening, closing and renaming files,
all of which are very expensive operations.
<P>
The revised object store exhibits the same read performance as
the original, but write performance has improved by approximately
30%. This has been achieved by storing both the shadow and committed
states of an object in the same file and providing an open file
cache to reduce the number of times a file is actually opened.
The interface to the object store is unchanged.
<P>
In order to make the management of the twin states in the same
file simpler they are stored starting at two distinct points in
the file - in the default implementation these points are 16Mb
apart thus allowing a single object state to occupy at most 16Mb.
Since most objects are nowhere near this size in reality, the
implementation relies on the fact that UNIX will create such files
with <I>holes</I> in them and not physically allocate the missing
space. Unfortunately use of any of the UNIX commands to read and
copy files (such as <I>cp</I>, <I>tar,</I> etc.) <I>will</I> cause
the space to be allocated and even small objects might suddenly
occupy 16Mb or more of real disc space.
<P>
To compensate for this, and to aid transition of old object states
to the new format, a utility program (<TT>OSConverter</TT>) is
provided which will convert between old states and new states
(and vice versa). Using this allows existing object stores to
be converted to the new format but also allows objects to be copied
(and archived) using normal UNIX commands simply by converting
the new state format back to the old format, doing the copy, and
then converting back to the new form.
<H2> The Volatile Object Store</H2>

<P>
The volatile object store makes use of UNIX System V shared memory
for storing and retrieving object states. When the first reference
to a volatile object store occurs a shared memory segment is created.
The default for the size of this segment is 1Mb, and the number
of object states which can reside within this is 200. The values
for these constants can be changed by modifying the appropriate
header file at system compilation time.
<PRE>
// @NoRemote, @NoMarshall
class LocalVolatileObjectStore : public ObjectStore
{
public:
    LocalVolatileObjectStore ();
    virtual ~LocalVolatileObjectStore ();

	// standard object store operations.

	....

	Boolean pack(Buffer&amp;);
   	Boolean unpack (Buffer);

private:
	....
};
</PRE>

<P>
The shared segment is retained for as long as a reference to the
volatile object store exists. Object states within this store
exist until the store is destroyed or they are explicitly removed.
Although the object store is volatile in that if the machine fails
the store and all of its object states are lost, it is possible
to save and restore the entire volatile store to and from disk
using the <TT>pack</TT> and <TT>unpack</TT> routines. These routine
should be used with caution as an <TT>unpack</TT> will completely
overwrite any states currently in the shared memory segment. The
<TT>pack</TT> operation stores all states into an instance of
a <TT>Buffer</TT> and it is then possible to save this to disk
using an instance of the persistent object store, and vice versa.
<H1> Arjuna Services and Tools</H1>

<H1> Arjuna System Components</H1>

<P>
In previous chapters we have described the basic components that
comprise <I>Arjuna</I>, and demonstrated how they can be used
to write fault-tolerant distributed applications. These next two
chapters are intended for the reader who is interested in knowing
how these components work and interact; how they are implemented;
and what plans there are for future development of the system.
<P>
Figure 7.1, shows the main system components that make up the
<I>Arjuna </I>system. Every node must contain the RPC and object-action
components; the entire <I>Arjuna</I> system must contain at least
one object store and (logically) one name server (the server may
be physically replicated, but should appear as a single entity).
<P>
<B>Figure 7.1: Arjuna System Structure</B>
<H2> Overview of the Arjuna Structure</H2>

<P>
The Object and Action Module (OA) is the main user of the services
provided by the remaining three components. Thus, OA uses the
Name Server Module (NS) for locating named persistent objects,
it uses the Object Store Module (OS) for retrieving the state
of the persistent object and the RPC Module (RM) for invoking
operations on objects. The basic sequence is as follows:
<P>
The user supplied name of the object is passed by OA to the name
server (NS) that returns the name of the host where the object
is stored, a path name of the executable code for the object,
and a unique identifier (Uid) for the object. The OA module then
uses RM to create a server at the (remote) host that contains
the object. This server is given both the path name and the Uid
of the object. The server runs code for the object and is ready
to execute operations on the object. When the first operation
request arrives, the server must retrieve the persistent state
of the object from the object store prior to executing the operation.
The server supplies both the object type (class name) and Uid
to the object store.- this information is sufficient for the object
store to locate the state of the object. Once a server has the
object state loaded, it need not access the object store for further
operation invocations.
<P>
Having briefly described the roles played by the components that
make up the <I>Arjuna</I> system, we shall examine each component
in more detail. We shall describe some of the design decisions
made and (where possible) give indications of possible future
modifications to the system.
<H2> The Name Server</H2>

<P>
The class <I>ArjunaName</I> is used to interface to the name server.
The interface between NS and OA is fairly simple. An instance
of the <I>ArjunaName</I> class maintains the following pieces
of information regarding an object:
<P>
1. A user defined object name.
<P>
2. The Uid of the object.
<P>
3. The hostname of the object store (currently also the place
where the server for the object will be created).
<P>
4. The &quot;service name&quot;: this is the name of the executable
file that contains the server code (the methods of the object).
<P>
The client program using OA will create an instance of <I>ArjunaName</I>,
filling in the fields as much as is necessary/possible and invoke
an appropriate operation of the name server to obtain the remaining
information. (See <U><B>section 6.1.</B></U>)
<H2> RPC Module</H2>

<P>
The RM provides several client and server primitives:
<P>
Client: initiate, multi_call, and terminate.
<P>
Server: init_server, getwork, sendresult.
<P>
The following rules are used for associating a server with an
object (an object with one or more servers attached to it will
be called <I>active</I>, otherwise it will be called <I>passive</I>.
A passive object resides in the object store, whereas an active
object is in volatile store).  (NOTE: since the stub generator
for the Arjuna system automatically creates the necessary code
for using the RM primitives, a programmer need not be concerned
with  the use of these primitives; so the rules are given here
for the sake of completeness).
<P>
1. An object must be made active before invoking its methods.
<P>
2. Different top-level atomic actions get independent servers.
<P>
3. Within a top-level atomic action, there is exactly one server
associated with an object.
<P>
4. A server is attached to a single object.
<P>
We shall now examine the RPC primitives that clients and servers
use.
<H3> At the Client</H3>

<P>
The <I>initiate</I> primitive is responsible for associating a
server with an object. If several objects are being created (say
n objects), initiate will try to associate r number of servers
(r&#163;n), where r is the number of objects now available (n-r
nodes with object copies are down, assuming the objects are on
distinct nodes).
<P>
i<TT>nitiate( listof{ destIN, methodnameIN, UidIN, serveridOUT},
<BR>
   actionidIN/OUT, successesIN/OUT, groupidOUT)</TT>
<P>
We assume that before initiating an object, the name server has
been contacted to obtain the relevant details. The subscripts
of a parameter describe whether the value is passed by the invoker
(IN) or a result is returned (OUT) or both (IN/OUT). The &quot;dest&quot;,
&quot;methodname&quot; and &quot;Uid&quot; refer respectively
to the hostname, pathname of the executable binary file (of methods
plus other code) at the host and the Uid of the object. The &quot;serverid&quot;
is the identifier of the server associated with the object. The
&quot;successes&quot; parameter specifies the number of objects
(if replicated) that must be initiated. Normally, this would be
&quot;all available&quot; - the returned value indicating the
actual number. Assume that an object has two copies on two distinct
nodes N2 and N3, (both up and running) and such an object is to
be initiated (from N1) for the first time within a top level action.
Initiate will first generate, at N1, a multicast identifier using
newid (this is the groupid) and if the top-level action has not
yet got an action identifier, initiate will generate such an identifier
as well; the servers on N2 and N3 are then created. These servers
initialise themselves by performing various housekeeping functions,
that includes joining the group &quot;groupid&quot;. Initiate
is &quot;failure atomic&quot; - either the specified number of
servers are created or none are.
<P>
The complimentary operation to initiate is terminate:
<P>
<TT>terminate (groupidIN, allIN)</TT>
<P>
The function is to &quot;uninitiate&quot; - if the invoker is
the only client of the group of servers, then all the servers
will be destroyed, otherwise the RM records the fact that the
caller is no longer a client. Thus if there are n clients of a
server group and each client executes a terminate, then the nth
terminate will destroy the group. The &quot;all&quot; parameter
does away with this behaviour and destroys the group regardless
of the reference count.
<P>
The client primitive multi_call is the group RPC primitive:
<P>
<TT>multi_call (groupidIN, requestIN, ResultOUT, TimeoutIN,<BR>
    RetryIN, FilterinfoIN/OUT)</TT>
<P>
The semantics of <I>multi_call</I> are: within the &quot;timeout&quot;
period, make at most &quot;retry + 1&quot; attempts to perform
the &quot;requested&quot; operation exactly once, on the group
of servers &quot;groupid&quot; who will return the result in &quot;result&quot;;
the &quot;filterinfo&quot; specifies (&quot;IN&quot;) the minimum
number who must return the result (that is expected to be identical
from each server), the &quot;OUT&quot; indicating the actual number
who replied. None of the above applies if the timeout occurs.
<P>
The RM detects and kills orphans caused by node crashes.
<H3> At the Server</H3>

<P>
A server's lifecycle is as follows: it initialises itself soon
after its creation:
<P>
<TT>init_server (argumentcountIN, argumentpointerIN)</TT>
<P>
A &quot;manager&quot; process (at a well known address) exists
at each node for creating servers. A client can create a server
at any node by using the initiate primitive discussed earlier
which results in the created server executing the above primitive.
The RM maintains, on every node, a &quot;statelist&quot; - that
contains information regarding the clients and objects of the
servers on that node. This list is used for enforcing the server-object
association rules discussed previously; in addition, this list
is also used by the orphan detection and elimination system (the
statelist was called the c_list in the original Rajdoot RPC paper).
The above primitive causes the server to &quot;log&quot; itself
in the statelist, and join the multicast group the client has
created.
<P>
Once created, the server waits for an RPC using the primitive
getwork:
<P>
<TT>getwork (sourceOUT, requestOUT, deadlineOUT,filterinfoIN/OUT)</TT>
<P>
Meaning: perform the &quot;requested&quot; operation, within the
specified &quot;deadline&quot; for the client &quot;source&quot;.
A primitive &quot;ondeadline&quot; is available for setting timeouts.
If the deadline expires, the server returns to &quot;getwork&quot;.
The filter is necessary when there are replicated clients, in
which case some application specific means of treating replicated
calls is necessary (replicated calls need to be merged in to a
single call).
<P>
If the server completes the requested operation before the deadline
expires, it returns the results of the operation via the primitive
sendresult:
<P>
<TT>sendresult (destinationIN, resultIN).</TT>
<P>
The RM maintains, on behalf of the server, the last results of
its clients - just in case it receives retries from clients for
already executed calls.
<P>
At present, the default number of retries is set to 2, and the
timeout between each retry is 5 seconds. Thus, if a server has
crashed the client will spend 15 seconds (5 seconds for the initial
RPC and 10 seconds for the 2 retries) attempting to contact the
server before deciding that it has failed.
<H2> Object Store</H2>

<P>
The object store at a node stores instances of a class <I>ObjectState</I>.
It is the responsibility of OA to convert an instance of <I>ObjectState
</I>retrieved from the object store to the appropriate user specific
persistent object (such as ResearchFund, see <U><B>section 6.1.2</B></U>).
Similarly, an object, such as ResearchFund, must be converted
back into an instance of <I>ObjectState </I>before handing it
over to the object store for safe keeping. The object store provides
two key operations:
<P>
<TT>read_state (objectTypeIN, UidIN, ObjectstateOUT)</TT>
<P>
which gets the &quot;<I>Objectstate</I>&quot; representation of
an object with identifier &quot;<I>Uid</I>&quot;, and class name
&quot;<I>objectType</I>&quot;. To store an instance of &quot;<I>Objectstate</I>&quot;,
the corresponding operation is:
<P>
<TT>write_state (objecttypeIN, UidIN, ObjectstateIN)</TT>
<H2> Object-Action</H2>

<P>
The bulk of the object-oriented research work within <I>Arjuna</I>
is represented by this sub-system. Several <I>Arjuna </I>papers
describe the class hierarchy used in OA to incorporate the properties
of atomic actions. The base class <I>StateManager</I> provides
the interface to the object store through two virtual operations:
<P>
<TT>restore_state(objectstateIN)</TT>
<P>
This operation transforms the ObjectState representation of the
user object as obtained from the object store into the user object
representation as indicated by the instance variables of the object;
<P>
<TT>save_state (objectstateOUT)</TT>
<P>
This operation performs the complimentary operation to obtain
the <I>ObjectState</I> representation, ready for safe keeping
in the object store.
<H2> Execution of an Application</H2>

<P>
To make the foregoing discussion more concrete, this section of
the document will describe the operational details of process
creation, operation invocation and distributed atomic action management
with respect to the current implementation. This description is
totally implementation dependent, but, as the current implementation
represents an instantiation of the design it may help the reader
to understand how the various pieces fit together.
<P>
For explanation, assume that a class developer has produced an
implementation of the class <TT>Stack</TT> discussed previously:
<PRE>
#include &lt;Common/Boolean.h&gt;
class Stack : public LockManager
{
public:
	Stack(char*);	// constructor
	~Stack();	// destructor

	Boolean Push(long val);
	Boolean Pop(long &amp;val);

	virtual Boolean save_state(ObjectState&amp;, ObjectType);
	virtual Boolean restore_state(ObjectState&amp;, ObjectType);
	virtual const TypeName type() const;

private:
	int top;
	long values[100];
};
</PRE>

<P>
 This <TT>Stack</TT> class is recoverable, persistent and concurrency-controlled.
After the class definition has been processed with the stub generator
resulting in five files: (1 and 2) the stub header files, <TT>Example_stub.h</TT>
and <TT>Stack_stubclass.h</TT>, (3) the client stub implementation,
<TT>Stack_client.cc</TT>, (4) the server stub implementation,
<TT>Stack_server.cc</TT>, (5) the server's main body implementation,
<TT>Stack_servermain.cc</TT>.
<P>
Let us consider what happens now when the application program
is executed by a user. Using the following program as an example,
we shall explain the actions taken by the Arjuna run-time system
at each stage of the execution of the program. We assume that
a stack object has been created previously, and registered in
the name server as &quot;mystack&quot;, together with other information,
e.g., hostname (see <U><B>section 6.1.</B></U>)
<PRE>
1.	#include &quot;Stack.h&quot;
2	
3	int main(int argc, char *argv[])
4	{
5		int v;
6		Boolean err;
7		ArjunaName AN(&quot;mystack&quot;);
8		ClientRpc *RPCClient = new ClientRpc(&amp;AN);
9		RpcControl *RPCCtl = new RpcControl(RPCClient);
10
11		Stack StackObj(AN, RPCCtl);	// access the StackObj, mystack
12		AtomicAction A;				// create an atomic action
13	
14		A.Begin();
15	
16		err = StackObj.push(10);		// push the number 10 onto the
17										// stack
18		err = StackObj.pop(v);		// pop the top of stack into v
19	
20		if (A.End() != COMMITTED) cerr &lt;&lt; &quot;Action commit error\n&quot;;
21	
22		return v;						// return the result
23	}
</PRE>

<P>
Initially, the application program is running on some node in
the network, e.g., node X (see figure 7.2). The application is
called a client because it will use the services of the server,
<TT>StackServer</TT>. For clarity, the crash recovery and orphan
detection processes have not been included in the diagrams. As
mentioned earlier, every node runs a <I>manager process</I> (the
figure below shows one for node Y) at a well known address whose
job is to create server processes as necessary.
<P>
<B>Figure 7.2: Application started, server not yet running</B>
<P>
When the constructor for <TT>StackObj</TT> is encountered in line
11 of the program, the client stub version of the constructor
will be executed. The following actions will be taken:
<P>
  The stub code will <I>initiate</I> the <TT>StackServer</TT>
on node <I>Y</I> by contacting the manager process on node <I>Y</I>
and requesting a connection to the <TT>StackServer</TT> there.
The manager process will then start the server.
<P>
  Finally, the stub code of the client side constructor will,
via a standard RPC, execute the actual <TT>Stack</TT> constructor
in the server, during which, it will initialise the <TT>StateManager</TT>
of the <TT>Stack</TT> object with the <TT>Uid</TT> (that was supplied
by the name server) that corresponds to persistent object &quot;mystack&quot;.
<P>
The system state at this point is depicted in figure 7.3.
<P>
<B>Figure 7.3: Application and server running</B>
<P>
When the constructor for <TT>AtomicAction A</TT> is executed (line
12 above), the infrastructure necessary for managing actions gets
created; in particular, a data structure is created to manage
the top-level atomic action at node <I>X</I> (the client node).
When the <TT>Atomic Action </TT>is begun (line 14) this data structure
is updated to reflect the new state of the action (running) and
the <I>current pointer</I> (a member within the class <I>AtomicAction</I>)
for the client process is set to point at atomic action <TT>A</TT>.
<P>
When the operation, <TT>push</TT> is invoked on the object <TT>StackObj</TT>,
the following operations occur at X:
<P>
2. The client stub code in the application process on node <I>X</I>
packs the argument, 10, into a <TT>RpcBuffer</TT> object, that
will be sent to the server at Y, via RPC,  with an indication
of the operation type (<TT>push</TT>).
<P>
3. The atomic action infrastructure is responsible for adding
some additional information about the current atomic action hierarchy
to the <TT>RpcBuffer</TT>.
<P>
4. The infrastructure is also responsible for adding some information
(an instance of <TT>RajdootCallRecord</TT>) to the <TT>AtomicAction
A</TT>, that indicate that the <TT>StackServer</TT> has been accessed
within that atomic action.
<P>
5. The RPC to the <TT>StackServer</TT> is now made.
<P>
At the server, the following operations occur:
<P>
6. At the server process, the action  infrastructure extracts
information from the received <TT>RpcBuffer</TT> about the atomic
action hierarchy under which this operation was invoked, and reconstructs
an image of that action hierarchy inside the server process at
node <I>Y</I>.
<P>
7. The server stub code in the server process unpacks the argument
and operation type information from the message.
<P>
8. The operation push is invoked on the object, &quot;mystack&quot;
in the server process. The body of <TT>push</TT> will contain
the necessary code for obtaining a write lock (by making use of
the <TT>setlock </TT>operation of <TT>LockManager </TT>class<TT>;
</TT>this will also ensure that the server has the latest persistent
state of the object available from the object store (this is indicated
by the dotted line in fig. 8.2).
<P>
9. The result of the push operation is returned to the server
stub code that packs its into a reply message that is then sent.
<P>
A similar sequence of operations occurs for each subsequent invocation
of operations on &quot;mystack&quot; from the client until the
atomic action commits (line 20 above). At this point, the code
of <TT>A.End</TT> examines the Records it contains, and sends
a prepare message to any server for which there is a <TT>RajdootCallRecord</TT>
(in this example, only &quot;mystack&quot;) - this is the first
phase of the two-phase commit protocol. When the server for &quot;mystack&quot;
receives the prepare message, it first prepares any servers that
it has called during action <TT>A</TT>. That is, any other <I>Arjuna</I>
objects that were accessed during operation invocations on &quot;mystack&quot;
(<TT>push, pop,</TT> etc). This is the &quot;standard&quot; hierarchical
commit protocol processing. If all these objects are also successfully
prepared (there are none in this example, so this condition is
trivially satisfied), the local objects are prepared. Then the
status of the prepare operation is returned to the client at node
X. If all server processes successfully prepared, the client sends
a commit message to all server processes used by action <TT>A</TT>.
This message is similarly propagated to all objects involved in
the atomic action. If any object failed to prepare, the atomic
action is aborted by sending an abort message instead.
<P>
At line 23 (logically), the destructor for &quot;mystack&quot;
is executed. The implementation of this operation will call <TT>Terminate</TT>
that will kill the server for &quot;mystack&quot;. The manager
process at Node Y notes the exit of this server in its database
of active servers.
<H1>Appendix A: Installation</H1>

<P>
Before <I>Arjuna</I> applications can be developed and executed
on your network, there are several steps that you or your system/network
administrator must perform. The purpose of this section is to
help you with this task.
<P>
This software has been tested on Sun3, Sun4 (SPARC) and HP9000/300
computers. Although not intentionally machine specific it requires
certain basic capabilities from the system, these include:
<P>
  BSD style Sockets (Rajdoot). If &quot;true&quot; multicasting
is to be used then network broadcast capabilities are also required.
<P>
  System V shared memory and semaphores (Arjuna).
<P>
  A version of imake (system building)
<P>
  A version of the C pre-processor that allows &quot;#pragma&quot;.
<P>
  Support for long file names.
<P>
  The system should be running <TT>rpc.statd</TT>, and <TT>rpc.lockd</TT>
daemons.
<P>
The <I>Arjuna</I> software consists of a collection of classes
implementing the Atomic Action system, and several system programs
that form the run-time support for Arjuna.
<H2>A.1 Loading the Sources</H2>

<P>
The source directory tree contains the current implementation
of the <I>Arjuna</I> system. Individual README files exist in
each sub-directory to supplement the information in this section.
You are advised to read them all before doing anything else.
<P>
The source is split into several sub-directories as documented
below. Each sub-directory contains one component of the complete
system. These components (and their directories) are currently:
<P>
ClassLib: This is the core code of <I>Arjuna</I>. It constitutes
a set of C++ classes that provide recovery, persistence, naming
and concurrency control mechanisms for user-defined classes, together
with the atomic action and system support classes.
<P>
Common: Classes used throughout the <I>Arjuna</I> system.
<P>
Config: Contains information about the system configuration.
<P>
Include: The header files used by the <I>Arjuna</I> system.
<P>
RPC:  The <I>Arjuna</I> RPC mechanism (Rajdoot) is within this
directory.
<P>
StubGen: The <I>Arjuna</I> stub generator that provides access
transparency to remote objects by creating stub objects that have
the same public interface as the original object but that have
all operations implemented as RPC calls to the actual remote object.
<P>
Util:  Contains some useful utilities, e.g., makedepend, ipcclean,
. . .
<P>
Tests:  Some simple tests to verify that the build of <I>Arjuna</I>
has completed<BR>
 correctly.
<P>
Applications: Some applications that exercise <I>Arjuna</I> in
interesting ways.
<H2>A.2 System Configuration</H2>

<P>
It is possible to configure the <I>Arjuna</I> to suit your system.
To do this, run the program <TT>configure</TT> in the top directory
of the <I>Arjuna</I> source. This program generates the file <TT>Local.def</TT>
in the <TT>Config</TT> directory.
<H2>A.3 Building and Installing the Software</H2>

<P>
To configure, build and install the <I>Arjuna</I> software, type:
<PRE>
configure
. . .	Answer questions
make -f MakefileBoot Makefiles
make depend
make all
make install
</PRE>

<P>
When making the Arjuna system the following make environment variables
are used:
<PRE>
TOPDIR = . . .

MAKE = make
IMAKE = imake
MAKEDEPEND = $(TOPDIR)/Util/bin/makedepend
STRIPDEPEND = $(TOPDIR)/Util/bin/stripdepend
C++ = CC
AR = ar
RANLIB = ranlib
YACC = yacc
LEX = lex
MV = mv
CP = cp
RM = rm
CAT = cat
MKDIR = mkdir
CHMOD = chmod

MAKEFLAGS = -e
MAKEDEPENDFLAGS = $(C++INCLUDE)
STRIPDEPENDFLAGS =
CPPFLAGS = . . .
C++FLAGS = . . .
LDFLAGS =  . . .
YACCFLAGS = -v -d
LEXFLAGS= 
</PRE>

<P>
Due to differences in <TT>make</TT> on some machines some of these
<TT>make</TT> environment variables can be renamed:
<PRE>
C++INCLUDE with CPLUSPLUSINCLUDE
C++ with CPLUSPLUS
C++FLAGS with CPLUSPLUSFLAGS
MAKEFLAGS with xMAKEFLAGS
</PRE>

<P>
Besides the <TT>make</TT> targets already mentioned, the generated
<TT>Makefile</TT>, also provides: 
<PRE>
Makefile_	Regenerates the Makefile in that directory.
Makefiles	Regenerates all the Makefiles in the sub-directories of the directory.
tidy	Removes all temporary files in the directory and its sub-directories.
clean	Removes all temporary files and object files in the directory and its sub-directories.
purge	Removes all temporary files, object files programs, and  Makefiles in the directory and its sub-directories.
</PRE>

<H2>A.4 Preparing Your System</H2>

<P>
Before installing the <I>Arjuna</I> software, we recommend the
following administrative steps be taken, assuming a default configuration
for <I>Arjuna</I>:
<P>
  Create a user (group) arjuna by adding a line to /etc/passwd
(/etc/group). The user arjuna being used to run the required daemons.
<P>
  If &quot;true&quot; mulitcasting is to be used then it will
be necessary to create a network called &quot;localnet&quot; by
adding a line to the /etc/networks, for example:
<P>
  localnet  128.240
<P>
  Make the directory into which headers, libraries, the stub generator
and daemons will be stored. This is typically named when running
the &quot;configure&quot; script, for example /usr/local/Arjuna
.
<P>
  Make an object store directory. This directory is used by <I>Arjuna</I>
to store away the states of persistent objects used by applications,
and is derived from the name specified in the &quot;configure&quot;
script, e.g., /usr/local/Arjuna/ObjectStore.
<H2>A.5 Booting the Arjuna Run-Time System</H2>

<P>
The <I>Arjuna</I> run-time support consists of run-time libraries
(<TT>libArjuna.a</TT>, <TT>libArjServers.a</TT>, <TT>libCommon.a</TT>
and <TT>libRajdoot.a</TT>, etc) that are linked with applications/servers
and a set of daemon processes that co-ordinate the distribution,
remote access and (crash) recovery mechanisms. There are several
daemon processes that are normally running on each node that is
participating in an Arjuna transaction:
<P>
The Housekeeper Daemon - implements orphan detection and manages
crash counts.
<P>
The Manager Daemon - is the object manager that creates new server
processes as objects get initiated.
<P>
The Recovery Manager - periodically scans the object store on
a node to discover objects whose state is ambiguous due to a crash
during transaction processing. The Recovery Manager contacts the
co-ordinator for the transaction to determine the outcome of the
transaction and takes appropriate action to resolve the state
of the object.
<P>
The Recovery Daemon - responds to queries from the Recovery Manager
about the state of transactions initiated on the node.
<P>
These daemon processes should be started at &quot;boot time&quot;.
The daemons should run as user arjuna and should be launched from
/tmp as they write various temporary files during execution.
<P>
The Manager Daemon expects to find all server executable code
residing in a default location which is derived from the installation
directory specified in the &quot;configure&quot; script, e.g.,
/usr/local/Arjuna/servers. This can be changed at manager run-time
by issuing the -p option followed by a new path name. An example
of creating a search path for the Manager could be:
<PRE>
	manager -p /tmp -p /user/arjuna
</PRE>

<P>
The Manager Daemon can be made to produce debugging information
by including the &quot;-d&quot; option.
<P>
Figure A.1, depicts an Arjuna application on Node X accessing
an object on Node Y.
<P>
<B>Figure A.1: Server processes that are active on nodes running
Arjuna</B>
<H2>A.6 Administration of Arjuna</H2>

<P>
Apart from ensuring that the run-time support daemons are executing
normally, there is little continuous administration needed for
the <I>Arjuna</I> software. There are a few points however, that
should be made:
<P>
  The present implementation of the <I>Arjuna</I> system provides
no security or protection for data. The objects stored in the
<I>Arjuna</I> object store are (typically) owned by user arjuna.
The Object Store and Object Manager facilities make no attempt
to enforce even the limited form of protection that Unix provides.
There is no checking of user or group IDs on access to objects
for either reading or writing.
<P>
  When we say persistent, we mean persistent. Persistent objects
created in the <I>Arjuna</I> Object Store never go away unless
some application program explicitly deletes them. This means that
the Object Store gradually accumulates garbage (especially during
application development and testing phases). At present we have
no automated garbage collection facility. Further, we have not
addressed the problem of dangling references. That is, a persistent
object, A, may have stored a UID for another persistent object,
B, in its passive representation on disk. There is nothing to
prevent an application from deleting B even though A still contains
a reference to it. When A is next activated and attempts to access
B, a run-time error will occur.
<P>
  The same kind of garbage collection issues arise in the internal
state of some objects, notably the Name Server. As applications
execute, permanent entries may be made in the Name Server. These
entries are not presently deleted except by explicit action of
some application program. This means that the Name Server database
tends to get cluttered over time (especially during development
and testing phases).
<P>
  The <I>Arjuna</I> Object Store is organized as an ordinary Unix
directory tree with no special protections or attributes. This
means that conventional Unix tools for backup and archiving can
be used to save the <I>Arjuna</I> objects.
<P>
  There is presently no support for version control of objects
or database reconfiguration in the event of class structure changes.
This is a complex research area that we have not addressed. At
present, if you change the definition of a class of persistent
objects, you are entirely responsible for ensuring that all old
instance of the object in the Object Store are converted to the
new representation. The <I>Arjuna</I> software can neither detect
nor correct references to old object state by new method versions
or vice versa.
<H1>Appendix B: Class Library</H1>

<P>
This chapter contains an overview of those classes that the application
programmer will typically use. The aim of this chapter is to provide
a quick reference guide to these classes for use when writing
applications in Arjuna. For clarity only the public interface
of the classes will be given.
<H2>B.1 ObjectState</H2>

<PRE>
// @NoRemote, @UserMarshall
class ObjectState : public Buffer
{
public:
    /* Constructors &amp; destructors */

    ObjectState ();
    ObjectState (const ObjectState&amp; copyFrom);
    ObjectState (const Uid&amp; newUid, TypeName tName);
    ObjectState (const Uid&amp; newUid, TypeName tName, size_t size, char *buffer);
    ~ObjectState ();

    /* non-virtual member functions and operators */

    char *buffer () const;
    Boolean notempty () const;
    size_t size () const;
    const Uid&amp; stateUid () const;
    const TypeName type () const;

    ObjectState&amp; operator= (const ObjectState&amp; objstate);

    /* virtual member functions and operators */

    virtual Boolean packInto (Buffer&amp; buff) const;
    virtual Boolean unpackFrom (Buffer&amp; buff);
    
    virtual ostream&amp; print (ostream&amp; strm) const;

private:
     . . .
};
</PRE>

<H2>B.2 StateManager</H2>

<PRE>
enum ObjectStatus
{
    PASSIVE, PASSIVE_NEW, ACTIVE, ACTIVE_NEW
};

enum ObjectType
{
    RECOVERABLE, ANDPERSISTENT, NEITHER
};
// @Remote, @NoMarshall
class StateManager
{
public:
    /* non-virtual member functions and operators */

    // @NoClient
    Boolean activate (ObjectStore * store = 0);
    // @NoClient
    Boolean deactivate (ObjectStore * store = 0, Boolean commit = TRUE);
    // @NoClient
    void resetState (ObjectStatus newState);

    // @NoClient
    void *operator new (size_t amount);
    // @NoClient
    void operator delete (void *memPtr);

    const Uid&amp; get_uid () const;

    /* virtual member functions */

    // @NoClient
    virtual void destroy ();
    // @NoClient
    virtual void disable ();

    // @NoClient
    virtual ostream&amp; print (ostream&amp; strm) const;

    virtual Boolean restore_state (ObjectState&amp; os, ObjectType ot) = 0;
    virtual Boolean save_state (ObjectState&amp; os, ObjectType ot) = 0;   
    virtual const TypeName type () const = 0;

protected:
/*  Constructors &amp; destructor */

    StateManager (ObjectType ot = RECOVERABLE);
    StateManager (const Uid&amp; objUid);
    virtual ~StateManager ();

    /* non-virtual member functions */

    void modified ();
    void persist ();
    void terminate ();

private:
    . . .
};
</PRE>

<H2>B.3 Buffer</H2>

<PRE>
enum BufferState { BUFFER_GOOD, BUFFER_BAD };     

// @NoRemote, @UserMarshall
class Buffer
{
public:
    /* Constructors &amp; destructor */
    
    Buffer (size_t buffSize = DEFAULT_CHUNK_SIZE);
    Buffer (size_t buffSize, char *buffer, Boolean full = TRUE,
	    Boolean shouldDel= TRUE);
    Buffer (const Buffer&amp; copyFrom);
    virtual ~Buffer ();
    
    /* non-virtual member functions and operators */
    
    char *buffer () const;
    size_t length () const;
    BufferState readState () const;
    void reread ();
    void rewrite ();

    Boolean setBuffer (size_t buffSize, char *buffer, Boolean full = TRUE,
		       Boolean shouldDel = TRUE);
    
    /* pack and unpack operations for standard types */
    
    Boolean pack (const char);
    Boolean pack (const unsigned char);
    Boolean pack (const int);
    Boolean pack (const unsigned int);
    Boolean pack (const long);
    Boolean pack (const unsigned long);
    Boolean pack (const short);
    Boolean pack (const unsigned short);
    Boolean pack (const float);
    Boolean pack (const double);
    Boolean pack (const char *);		   /* null terminated string */
    Boolean pack (const char *, const size_t);  /* contiguous block of memory */
    
    Boolean unpack (char&amp;);
    Boolean unpack (unsigned char&amp;);
    Boolean unpack (int&amp;);
    Boolean unpack (unsigned int&amp;);
    Boolean unpack (long&amp;);
    Boolean unpack (unsigned long&amp;);
    Boolean unpack (short&amp;);
    Boolean unpack (unsigned short&amp;);
    Boolean unpack (float&amp;);
    Boolean unpack (double&amp;);
    Boolean unpack (char* &amp;, Boolean = FALSE);
    Boolean unpack (char *&amp;, size_t&amp;);
    
    /* other operators */
    
    Buffer&amp; operator= (const Buffer&amp;);	/* assignment that copies the buffer */
    Buffer&amp; operator+= (const Buffer&amp;);	/* concatentation operator */
    Boolean operator== (const Buffer&amp;); /* equality operator */
    
    /* virtual member functions and operators */

    /* Allow Buffers to be packed into other Buffers */

    virtual Boolean packInto (Buffer&amp;) const;
    virtual Boolean unpackFrom (Buffer&amp;);
   
    virtual ostream&amp; print (ostream&amp;) const;

private:
    . . .
};
</PRE>

<H2>B.4 Uid</H2>

<PRE>
// @NoRemote, @UserMarshall
class Uid
{
public:
    /* Constructors &amp; destructor */

    Uid ();
    Uid (const Uid&amp; copyFrom);
    Uid (const char *uidString, Boolean errsOk = FALSE);
    ~Uid ();

    /* non-virtual member functions and operators */

    unsigned long hash () const;
    Boolean pack (Buffer&amp; packInto) const;
    ostream&amp; print (ostream&amp; strm) const;
    Boolean unpack (Buffer&amp; unpackFrom);

    int operator== (const Uid&amp; u) const;
    int operator!= (const Uid&amp; u) const;
    int operator&lt;  (const Uid&amp; u) const;
    int operator&gt;  (const Uid&amp; u) const;

private:
    . . .
};

extern const Uid NIL_UID;
</PRE>

<H2>B.5 LockManager</H2>

<PRE>
enum LockResult
{
    GRANTED, REFUSED, RELEASED
};

enum ReleaseType
{
    SINGLE_LOCK, ALL_LOCKS
};

enum ConflictType
{
    CONFLICT, COMPATIBLE, PRESENT
};
// @Remote, @NoMarshall
class LockManager : public StateManager
{
public:
    // @NoClient
    void propagate (const Uid&amp; actionUid); /* propagate all locks to parent */
    // @NoClient
    LockResult releaseAll (const Uid&amp; actionUid);	/* release all locks for action */
    // @NoClient
    LockResult releaselock (const Uid&amp; lockUid); /* release one lock */

    // @NoClient
    LockResult setlock (Lock *toSet, int retry = 100); /* user visible setlock */

    /* virtual functions inherited from StateManager */

    // @NoClient
    virtual ostream&amp; print (ostream&amp; strm) const;
    // @NoClient
    virtual ostream&amp; print (ostream&amp; strm);

    virtual Boolean restore_state (ObjectState&amp; os, ObjectType ot) = 0;
    virtual Boolean save_state (ObjectState&amp; os, ObjectType ot) = 0;
    virtual const TypeName type () const;

protected:
    /* Constructors and destructor */

    LockManager (ObjectType ot = RECOVERABLE);
    LockManager (const Uid&amp; storeUid);
    ~LockManager ();

private:
    . . .
};
</PRE>

<H2>B.6 AtomicAction</H2>

<PRE>
enum ActionType
{
    TOP_LEVEL, NESTED, TOP_LEVEL_NESTED
};

enum ActionStatus
{
    CREATED, RUNNING, ABORTING, ABORTED,
    PREPARING, PREPARED, UNPREPARED, COMMITTING, COMMITTED,
    DONT_INTERRUPT, INVALID
};
//  @NoRemote, @NoMarshall	
class AtomicAction : public LocalStateManager
{
public:
    /* Constructors and destructor */

    AtomicAction ();
    AtomicAction (const Uid&amp; actUid);
    virtual ~AtomicAction();

    static AtomicAction *Current ();

    /* non-virtual member functions and operators */

    Boolean add (AbstractRecord *ar); 
    Boolean isAncestor (const Uid&amp; descendant ); 
    AtomicAction *parent ();
    ActionStatus status();
    ObjectStore *store ();
    const Uid&amp; top_level_action ();

    /* virtual member functions and operators */

    virtual ActionStatus Abort ();    
    virtual ActionStatus Begin ();
    virtual ActionStatus End ();

    virtual const Uid&amp; getSavingUid () const;

    /* inherited public virtual functions */

    virtual Boolean restore_state (ObjectState&amp;, ObjectType);
    virtual Boolean save_state (ObjectState&amp;, ObjectType);
    virtual const TypeName type () const;
    
protected:
    /* non-virtual member functions and operators */

    void criticalEnd ();
    void criticalStart ();
    void phase2Commit ();
    void phase2Abort ();
    PrepareOutcome prepare ();
    
    /* virtual member functions and operators */

    virtual void terminate ();

    /* note the static declaration of the following */

    static AtomicAction *currentAct;

     /* Should Be Private */

    ObjectStore *currentStore;

private:
    . . .
};
</PRE>

<H2>B.7 ClientRpc</H2>

<PRE>
class ClientRpc : public ClientRajdootAction_rpc
{
public:
    ClientRpc (ArjunaName* AN);
    ClientRpc (const char* sname = NULL);
    ~ClientRpc ();
};
</PRE>

<H2>B.8 RpcControl</H2>

<PRE>
class RpcControl
{
public:
    RpcControl (ClientRpc * = 0);
    RpcControl (const char *);
    virtual ~RpcControl ();

    RPC_Status Call (long, RpcBuffer&amp;, long&amp;, RpcBuffer&amp;);
    
private:
    . . .    
};
</PRE>

<H2>B.9 ArjunaName</H2>

<PRE>
// @NoRemote, @UserMarshall
class ArjunaName
{
public:
    /* Constructors &amp; destructor */

    ArjunaName ();
    ArjunaName (const char* Name);
    ~ArjunaName ();

    void LookUp();
    void Register();
    void Register(const char*, StateManager*);

    void SetObjName(const char*);
    void SetObjUid(const Uid*);
    void SetServiceName(const char*);
    void SetHostName(const char*);

    char* GetObjName();
    Uid*  GetObjUid();
    char* GetServiceName();
    char* GetHostName();

    char* GetRefObjName();
    Uid*  GetRefObjUid();
    char* GetRefServiceName();
    char* GetRefHostName();

    Boolean pack (Buffer&amp;) const;
    Boolean unpack (Buffer&amp;);

    ostream&amp; print ( ostream&amp; strm ) const;

private:
    . . .
};
</PRE>

<H2>ObjectStore Class</H2>

<PRE>
enum FileType { SHADOW, ORIGINAL, HIDDEN };

/*
 * This is the base class from which all object store types are
 * derived.
 * Note that because object store instances are stateless, to improve
 * efficiency we try to only create one instance of each type per
 * process. Therefore, the create and destroy methods are used
 * instead of new and delete. If an object store is accessed via
 * create it *must* be deleted using destroy. Of course it is still
 * possible to make use of new and delete directly and to create
 * instances on the stack.
 */
// @NoRemote, @NoMarshall
class ObjectStore
{
public:
    virtual ~ObjectStore ();

    /* The real interface */

	virtual Boolean commit_state (const Uid&amp;, const TypeName) = 0;
	virtual ObjectState *read_state (const Uid&amp;, const TypeName) = 0;
	virtual ObjectState *read_uncommitted (const Uid&amp;,
											 const TypeName) = 0;
	virtual Boolean remove_state (const Uid&amp;, const TypeName) = 0;
    virtual Boolean remove_uncommitted (const Uid&amp;,
										  const TypeName) = 0;
    virtual Boolean write_committed (const Uid&amp;,
							const TypeName, const ObjectState&amp;) = 0;
    virtual Boolean write_state (const Uid&amp;, const TypeName,
								   const ObjectState&amp;) = 0;
 
    virtual ObjectState *allObjUids (const TypeName) = 0;

    virtual const TypeName type () const = 0;
    virtual const char *getStoreName () const;

    /* These methods only make sense for remote object store */

    virtual void storeLocation (char**, int = 0);
    virtual void useStoreLocation (const Boolean);
    virtual void setObjectData (const Uid&amp;, const TypeName);

    static ObjectStore* create (const TypeName, const char* = 0);
    static void destroy (ObjectStore*&amp;);

	....

protected:
	....
};
</PRE>

<H2>B.10 Debug Class</H2>

<PRE>
/*
 *
 * Arjuna debugging system
 *
 * The following conventions should be followed:
 *
 * 1. All debugging statements should be within an
 *    #ifdef DEBUG
 *    #endif
 *    expression.
 *
 * 2. To indicate at what level, etc. the debugging info is use
 *    debug_stream &lt;&lt; CONSTRUCTOR &lt;&lt; VIS_PUBLIC ... etc. That is,
 *    insert the facility code, level and visibility into the debug
 *    stream.
 *
 * 3. Use debug_stream &lt;&lt; (whatever) to insert the actual debugging
 *    output. It is probably preferable to flush the output also. Output
 *    will only be produced if the inserted code, level, etc. match the
 *    currently requested debugging level.
 *
 * 4. To set the debug tracing level, the variable
 *    _arjuna_debug must be set to the level of tracing required.
 *    Since each level is represented by a bit in the variable,
 *    multiple levels are produced by OR-ing the fields together.
 *
 */
/* 
 * Enumerated types for FacilityCodes, Visibility levels and
 * overall debugging level. Can be inserted into a debug stream
 * to set the levels for the 'following' debugging output and also
 * used to set the overall values governing output.
 */
 
enum FacilityCode
{
    FAC_BASIC_RPC = 0x0001,
    FAC_ATOMIC_ACTION = 0x0002,
    FAC_CONCURRENCY_CONTROL = 0x0004,
    FAC_BUFFER_MAN = 0x0008,
    FAC_ABSTRACT_REC = 0x0010,
    FAC_OBJECT_STORE = 0x0020,
    FAC_STATE_MAN = 0x0040,
    FAC_ACTION_RPC = 0x0080,
    FAC_SHMEM = 0x0100,
    FAC_GENERAL = 0x0200,
    FAC_USER1 = 0x0400,
    FAC_USER2 = 0x0800,
    FAC_USER3 = 0x1000,
    FAC_USER4 = 0x2000,
    FAC_USER5 = 0x4000,
    FAC_USER6 = 0x8000,
    FAC_ALL = 0xffff
};
enum VisibilityLevel
{
    VIS_PRIVATE = 0x0001,
    VIS_PROTECTED = 0x0002,
    VIS_PUBLIC = 0x0004,
    VIS_ALL = 0xffff
};
enum DebugLevel
{
    NO_DEBUGGING = 0,
    CONSTRUCTORS = 0x0001,
    DESTRUCTORS = 0x0002,
    CONSTRUCT_AND_DESTRUCT = CONSTRUCTORS | DESTRUCTORS,
    FUNCTIONS = 0x0010,
    OPERATORS = 0x0020,
    FUNCS_AND_OPS = FUNCTIONS | OPERATORS,
    ALL_NON_TRIVIAL = CONSTRUCT_AND_DESTRUCT | FUNCTIONS | OPERATORS,
    TRIVIAL_FUNCS = 0x0100,
    TRIVIAL_OPERATORS = 0x0200,
    ALL_TRIVIAL = TRIVIAL_FUNCS | TRIVIAL_OPERATORS,
    FULL_DEBUGGING = 0xffff
};
/*
 * The real debug controller class
 */

class Dbg_Ostream;

class DebugController : public StreamFilter
{
public:
    /* Constructor */

    DebugController ();
    virtual ~DebugController ();

    /* non-virtual public functions */

    void set_all (DebugLevel, FacilityCode, VisibilityLevel); 
    void set_debuglevel (DebugLevel);
    void set_facility (FacilityCode);
    void set_visibility (VisibilityLevel);

    Dbg_Ostream&amp; stream ();

    /* virtual filtering function */
#ifdef NO_NESTED_TYPES
    virtual int filter (const char *, int, open_mode);
#else
    virtual int filter (const char *, int, ios::open_mode);
#endif

private:
    . . .
};
/*
 * Class to handle initialisation of debug system. Follows the scheme
 * adopted by the iostream library. That is, it's complicated and perverse!
 * Handle with care...
 * One instance gets created per object file compiled.
 */

static class Debug_Init
{
public:
    Debug_Init ();
    ~Debug_Init ();

private:
    static int init_count;
} debug_init;

/*
 * The following variables are defined in Debug.cc
 */

extern DebugController *_arjuna_debug;
/*
 * We define debug_stream as a cpp macro that maps to the stream held
 * inside the debug controller. Debug_Init ensures that this exists
 * very early on in execution.
 */

#define debug_stream ((_arjuna_debug != 0)?(_arjuna_debug-&gt;stream()):(_arjuna_debug = new DebugController(),_arjuna_debug-&gt;stream()))
/*
 * A special class derived from ostream for debugging purposes.
 * It maintains the level, visibility and facility of the current
 * output been sent to the stream via operator&lt;&lt;.
 * This used to be done by extending the basic ostream state using
 * xalloc() and iword() but libg++ does not currently implement
 * this part of the iostream library hence this route
 */

class Dbg_Ostream : public ostream
{
public:
    Dbg_Ostream (StreamFilter&amp;);
    ~Dbg_Ostream ();

    int fac () const;
    int lvl () const;
    int vis () const;

    void set_fac (FacilityCode);
    void set_lvl (DebugLevel);
    void set_vis (VisibilityLevel);

private:
    int facility, visib , level;
};
</PRE>

<H1>Appendix C: A Glossary of Arjuna Classes</H1>

<P>
<B>ActivationRecord<BR>
</B>ActivationRecords manage the correct activation and deactivation
of object's states. They are created when an object is first activated
inside the scope of an atomic action.
<P>
<B>CadaverLockManager<BR>
</B>Instances of this class are created by instances of the CadaverLockRecord
class for the sole purpose of lock cleanup due to a locked object
going out of scope prior to action termination. Serialisability
prevents locks being released as scope is exited thus they must
be cleaned up later. 
<P>
<B>CadaverLockRecord<BR>
</B>Instances of this record class are created by LockManager
if the object goes out of scope prior to the end of a manipulating
action. The intention is that the operations of this class will
clean up those locks that get left set as the object goes out
of scope but which must remain held until the action ends otherwise
serialisability is compromised. 
<P>
<B>CadaverRecord<BR>
</B>Cadaver records are created whenever a persistent object is
deleted while still in the scope of an atomic action. This ensures
that if the action commits the state of the persistent objects
gets properly reflected back in the object store. For objects
that are only recoverable such work is unnecessary. Cadaver records
replace PersistenceRecords in the record list of an atomic action
so they must be merged with such records to enable both commits
and aborts to occur. 
<P>
<B>ListIterator<BR>
</B>This class is used to traverse the list of AbstractRecords.

<P>
<B>LockIterator<BR>
</B>This class traverses the list of LockRecords. 
<P>
<B>LockList<BR>
</B>This class maintains the list of locks acquired. 
<P>
<B>LockRecord<BR>
</B>Lock records are created whenever a lock is acquired on object.

<P>
<B>LockStore<BR>
</B>Simple Shared Lock Store. Provides similar interface as the
object store but uses shared memory. 
<P>
<B>PersistenceRecord<BR>
</B>PersistenceRecords manage old states of persistent objects.
They are created when a persistent object is first modified inside
the scope of an atomic action. 
<P>
<B>RajdootCadaverRecord<BR>
</B>Whenever a Rajdoot RPC interface reference is deleted a RajdootCadaverRecord
is created that is a copy of this interface. This is necessary
for the same reasons as mentioned in CadaverRecord. 
<P>
<B>RajdootCallRecord<BR>
</B>These records maintain the information about which servers
have been sent RPC requests during an atomic action. 
<P>
<B>RajdootInitiateRecord<BR>
</B>These records maintain the information about which servers
have been successfully initiated during an atomic action. 
<P>
<B>RajdootTerminateRecord<BR>
</B>Servers should not be terminated until the top-level action
within which they were created has either committed or aborted.
If terminate is called on a server within an action then a RajdootTerminateRecord
is created that records this information and the actual terminate
called will be delayed until the top-level action completes. 
<P>
<B>RecordList<BR>
</B>This class manages instances of the classes derived from AbstractRecord
in the form of an ordered doubly-linked list. 
<P>
<B>RecoveryRecord<BR>
</B>RecoveryRecords manage old states of objects. They are created
when an object is first modified inside the scope of an atomic
action. 
<P>
<B>Semaphore<BR>
</B>Basic Semaphore Class Implementation. 
<P>
<B>ServerAtomicAction<BR>
</B>This class handles the atomic action mechanism at the remote
server. 
<P>
<B>SharedSegment<BR>
</B>Shared memory segment manager. 
<P>
<B>AbstractRecord<BR>
</B>This class provides an abstract template that defines the
interface that the atomic action system uses to notify objects
that various state transitions have occurred as the 2-phase commit
protocol executes. Record types derived from this class manage
certain properties of objects such as recovery information, concurrency
control information etc, and all must redefine the operations
defined here as abstract to take appropriate action. 
<P>
<B>ArjunaName<BR>
</B>This class represents a front-end to the remote object naming
service. 
<P>
<B>AtomicAction<BR>
</B>This class handles the atomic action mechanism. 
<P>
<B>Buffer<BR>
</B>Class that implements the marshalling operations for the basic
types. 
<P>
<B>ClientRajdootAction_rpc<BR>
</B>This class provides C++ interface to the client side of the
Rajdoot rpc protocol, that is tailored for &quot;atomic actions&quot;.

<P>
<B>ClientRajdoot_rpc<BR>
</B>This class provides C++ interface to the client side of the
Rajdoot rpc protocol. 
<P>
<B>Lock<BR>
</B>This class implements the locks that are set on objects to
enforce concurrency control. 
<P>
<B>LockManager<BR>
</B>LockManager manages the concurrency control. 
<P>
<B>NameServer<BR>
</B>This class provides the current naming service implementation.

<P>
<B>ObjectState<BR>
</B>This class is used to hold both the recovery data and persistent
data required by a class derived from StateManager. 
<P>
<B>ObjectStore<BR>
</B>This class implements the operations for saving and restoring
instances of ObjectStates to and from the object store. 
<P>
<B>RecordType<BR>
</B>This maintains the information about what record types are
available in the system. New records can be added by modifying
the information. 
<P>
<B>ServerRajdootAction_rpc<BR>
</B>This class provides C++ interface to the server side of the
Rajdoot rpc protocol, that is tailored for &quot;atomic actions&quot;.

<P>
<B>ServerRajdoot_rpc<BR>
</B>This class provides C++ interface to the server side of the
Rajdoot rpc protocol. 
<P>
<B>StateManager<BR>
</B>This class provides the operations necessary for activating
and deactivating persistent objects. 
<P>
<B>Uid<BR>
</B>This class implements the Unique Identifiers that are necessary
for naming persistent object states in the system.
<H1>Appendix D: Arjuna Papers</H1>

<P>
1. S. K. Shrivastava, G. N. Dixon, G. D. Parrington.<BR>
<I>Objects and Actions in Reliable Distributed Systems,<BR>
</I>IEE Software Engineering Journal, Vol. 2, No. 5, pp. 160-168,
September 1987.
<P>
2. F. Panzieri, S. K. Shrivastava.<BR>
<I>Rajdoot: A Remote Procedure Call Mechanism Supporting Orphan
Detection and Killing.<BR>
</I>IEEE Transactions on Software Engineering, Vol. SE-14, No.
1, pp. 30-37, January 1988.
<P>
3. G. N. Dixon.<BR>
<I>Object Management for Persistence and Recoverability.<BR>
</I>University of Newcastle upon Tyne, Computing Laboratory, Technical
Report Series, No. 276, December 1988. (Ph.D. Thesis) 
<P>
4. G. D. Parrington.<BR>
<I>Management of Concurrency in a Reliable Object-Oriented System.
<BR>
</I>University of Newcastle upon Tyne, Computing Laboratory, Technical
Report Series, No. 277, December 1988.<BR>
(Ph.D. Thesis).
<P>
5. G. N. Dixon, S. K. Shrivastava.<BR>
<I>Exploiting Type Inheritance Facilities to Implement Recoverability
in Object Based Systems.<BR>
</I>Proceedings of Sixth Symposium on Reliability in Distributed
Software and Database Systems, Williamsburg, pp. 107-114, March
1987.
<P>
6. G. N. Dixon, S. K. Shrivastava, G. D. Parrington.<BR>
<I>Managing Persistent Objects in Arjuna: A System for Reliable
Distributed Computing.<BR>
</I>Proceedings of Workshop on Persistent Object Systems, Persistent
Programming Research Report, No. 44, Department of Computational
Science, University of St. Andrews, August 1987. 
<P>
7. S. K. Shrivastava, L. Mancini, B. Randell.<BR>
<I>On the Duality of Fault-Tolerant System Structures.<BR>
</I>Proceedings of Workshop on Experiences with Distributed Systems,
Kaiserslautern, West Germany, September 1987. (Lecture Notes in
Computer Science, Vol. 309, Experiences with Distributed Systems,
Springer-Verlag, pp. 19-37, September 1987.) 
<P>
8. G. D. Parrington, S. K. Shrivastava.<BR>
<I>Implementing Concurrency Control in Reliable Distributed Object-Oriented
Systems.<BR>
</I>Proceedings of the Second European Conference on Object-Oriented
Programming, ECOOP88, Oslo, Norway, August 1988. (Lecture Notes
in Computer Science, Vol. 322, Springer-Verlag, pp. 233-249, 1988.).

<P>
9. S. K. Shrivastava, G. N. Dixon, M. C. Little, G. D. Parrington,
F. Hedayati, S. M. Wheater.<BR>
<I>The Design and Implementation of Arjuna.<BR>
</I>University of Newcastle upon Tyne, Computing Laboratory, Technical
Report Series, No. 280, March 1989.
<P>
10. G. N. Dixon, G. D. Parrington, S. K. Shrivastava, S. M. Wheater.
<BR>
<I>The Treatment of Persistent Objects in Arjuna. <BR>
</I>Proceedings of the Third European Conference on Object-Oriented
Programming, ECOOP89, University of Nottingham, pp. 169-189, July
1989.
<P>
11. S. K. Shrivastava, S. M. Wheater.<BR>
<I>Objects and Multi-Coloured Actions.<BR>
</I>Proceedings of Third Workshop on Large Grained Parallelism,
SEI, Pittsburgh, October 1989.
<P>
12. G. D. Parrington.<BR>
<I>Reliable Distributed Programming in C++: The Arjuna Approach.
<BR>
</I>Second Usenix C++ Conference, San Fransisco, pp. 37-50, April
1990. 
<P>
13. S. K. Shrivastava, S. M. Wheater.<BR>
<I>Implementing Fault-Tolerant Distributed Applications Using
Objects and Multi-Coloured Actions.<BR>
</I>Proceedings of Tenth International Conference on Distributed
Computing Systems, Paris, France, pp. 203-210, May 1990. 
<P>
14. D. L. McCue, S. K. Shrivastava.<BR>
<I>Structuring Fault-Tolerant Object Systems for Portability.
<BR>
</I>Fourth ACM SIGOPS Workshop, September 1990, Bologna. 
<P>
15. M. C. Little, S. K. Shrivastava.<BR>
<I>Replicated K-Resilient Objects in Arjuna.<BR>
</I>Proceedings of IEEE Workshop on the Management of Replicated
Data, Houston, Texas, pp. 53-58, November 1990. 
<P>
16. S. M. Wheater.<BR>
<I>Constructing Reliable Distributed Applications Using Actions
and Objects.<BR>
</I>University of Newcastle upon Tyne, Computing Laboratory, Technical
Report Series, No. 316, June 1990. (Ph.D. Thesis) 
<P>
17. S. K. Shrivastava, G. N. Dixon, G. D. Parrington.<BR>
<I>An Overview of the Arjuna Distributed Programming System.<BR>
</I>IEEE Software, pp. 66-73, January 1991.
<P>
18. M. C. Little.<BR>
<I>Object Replication in a Distributed System<BR>
</I>University of Newcastle upon Tyne, Computing Laboratory, September
1991. (Ph.D. Thesis) 
<P>
19. S. M. Wheater, D. L. McCue.<BR>
<I>Configuring Distributed Applications using Object Decomposition
in an Atomic Action Environment<BR>
</I>Proceedings of the International Workshop on &quot;Configurable
Distributed Systems&quot;, Imperial College, London, UK, March
1992.
<P>
20. D. L. McCue.<BR>
<I>Developing a class hierarchy for object-oriented transaction
processing,<BR>
</I>To be presented at ECOOP 92, July 1992.
</BODY>

</HTML>
